<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>js | 珊珊的小本子</title><meta name="author" content="ms.y,yeminshan@126.com"><meta name="copyright" content="ms.y"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="js实现的组成 ECMAScript 核心  ECMA-262 DOM 文档对象模型 BOM 浏览器对象模型 HTML 使用js浏览器解析到 &amp;lt;script&amp;gt;&amp;lt;&amp;#x2F;script&amp;gt; 标签时，它会立即停止解析 HTML 并开始加载 JavaScript 脚本。 在 &amp;lt;scri"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ms-yip.github.io/2022/12/04/js/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":false,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'js',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-05 14:59:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="珊珊的小本子" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">113</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">珊珊的小本子</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">js</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-04T03:18:26.000Z" title="发表于 2022-12-04 11:18:26">2022-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-05T06:59:44.985Z" title="更新于 2024-02-05 14:59:44">2024-02-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="js"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>js实现的组成</p>
<p>ECMAScript 核心  ECMA-262</p>
<p>DOM 文档对象模型</p>
<p>BOM 浏览器对象模型</p>
<h2 id="HTML-使用js"><a href="#HTML-使用js" class="headerlink" title="HTML 使用js"></a>HTML 使用js</h2><p>浏览器解析到 <code>&lt;script&gt;&lt;/script&gt;</code> 标签时，它会立即停止解析 HTML 并开始加载 JavaScript 脚本。</p>
<p>在 <code>&lt;script&gt;</code> 标签中，可以使用 <code>async</code> 和 <code>defer</code> 属性来控制脚本的加载和执行方式：</p>
<ul>
<li><p><code>async</code> 属性表示脚本可以异步加载，加载完成后立即执行。</p>
<p>异步加载的脚本不会阻塞页面的解析和渲染，但是执行时可能会阻塞其他 JavaScript 代码的执行，</p>
<p>因此适用于不依赖其他脚本的独立脚本。</p>
</li>
<li><p><code>defer</code> 属性表示脚本可以延迟到文档解析完成之后再执行。立即下载，延迟执行【有先后顺序】</p>
<p>延迟加载的脚本不会阻塞页面的解析和渲染，也不会阻塞其他 JavaScript 代码的执行，</p>
<p>因此适用于需要等待<strong>文档完全加载后才能执行的脚本</strong>，或者依赖其他脚本执行的脚本。</p>
</li>
</ul>
<p>script 标签可以放置在 html 任意位置，head、body，甚至是 div 里。它们——无论是内联还是外置——的执行顺序基本上（async 和 defer 除外）秉承由上至下串行执行的原则。浏览器首次加载 script 期间，还会阻塞 HTML 页面解析；尤其是外置引入 JS，需要经历网络传输、解析和执行，有时候会导致浏览器白屏。所以谈到首屏渲染的时候，我们往往会建议将 script 标签放到 <code>&lt;body&gt;</code> 元素的最下方——先呈现页面再执行 JS。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2752925170a44126b8dc418f8f02d3c8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="async vs. defer"></p>
<p>在 script 标签里指定 <code>type=&quot;module&quot;</code>，当脚本使用 import 指令时，浏览器会自动请求并加载相关的 JS 文件。</p>
<p>数据类型：</p>
<p>Undefined、null、string、number、boolean、object</p>
<p>typeof </p>
<p>undefined 未被定义</p>
<p>boolean 布尔型</p>
<p>string 字符串</p>
<p>number 数值</p>
<p>object 对象或 null</p>
<p>function 函数</p>
<p>Undefined 类型：声明未初始化 typeof(未声明的值) = undifined</p>
<p>Null类型：空对象指针 null == undefined // true  null === undefined // false</p>
<p>Bolean类型：true、false 两个值  Bolean(false|| “” ||0 || NaN || null ||undefined) = false</p>
<p>Number类型：NaN 是特殊的数值（Not a Number）</p>
<p>NaN == NaN  // false</p>
<p>isNaN(XXX) </p>
<table>
<thead>
<tr>
<th>进制</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>十进制(默认)</td>
<td>var initNum = 55</td>
</tr>
<tr>
<td>八进制(0开头，0-7)</td>
<td>var num = 070</td>
</tr>
<tr>
<td>十六进制(0x开头，0-9，a-f)</td>
<td>var num = 0x1f</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>进制转换</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Number</td>
<td></td>
</tr>
<tr>
<td>parseInt</td>
<td>parseInt(XX,2|8|10| 16)</td>
</tr>
<tr>
<td>parseFloat</td>
<td></td>
</tr>
</tbody></table>
<p>String 类型：</p>
<p>转为字符串：</p>
<ol>
<li>toString() =&gt; null undifined 没有这个方法</li>
<li>String()  =&gt; 任何类型转换成字符串有toString方法调用并返回，null 返回nll undefined 返回undefined</li>
</ol>
<p>Object 类型：</p>
<p>object实例 包含以下属性和方法：</p>
<ol>
<li><strong>constructor</strong>: <em>ƒ Object()</em> 构造函数 用于创建当前对象的函数</li>
<li><strong>hasOwnProperty</strong>: <em>ƒ hasOwnProperty()</em> 检查当前属性是否在当前对象实例中</li>
<li><strong>isPrototypeOf</strong>: <em>ƒ isPrototypeOf()</em> 检查对象是否是另一个对象的原型</li>
<li><strong>propertyIsEnumerable</strong>: <em>ƒ propertyIsEnumerable()</em> 检查给定的属性是否能够使用for-in语句枚举 和hasOwnProperty()方法一样</li>
<li><strong>toLocaleString</strong>: <em>ƒ toLocaleString()</em> 返回对象的字符串表示</li>
<li><strong>toString</strong>: <em>ƒ toString()</em> 返回对象的字符串表示</li>
<li><strong>valueOf</strong>: <em>ƒ valueOf()</em> 返回对象的字符串、数值或者布尔值表示</li>
<li><strong><strong>defineGetter</strong></strong>: <em>ƒ <strong>defineGetter</strong>()</em> </li>
<li><strong><strong>defineSetter</strong></strong>: <em>ƒ <strong>defineSetter</strong>()</em></li>
<li><strong><strong>lookupGetter</strong></strong>: <em>ƒ <strong>lookupGetter</strong>()</em></li>
<li><strong><strong>lookupSetter</strong></strong>: <em>ƒ <strong>lookupSetter</strong>()</em></li>
<li><strong><strong>proto</strong></strong>: Object</li>
<li>get <strong>proto</strong>: <em>ƒ <strong>proto</strong>()</em></li>
<li>set <strong>proto</strong>: <em>ƒ <strong>proto</strong>()</em></li>
</ol>
<p>操作符</p>
<table>
<thead>
<tr>
<th>一元操作符</th>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>递增、递减操作符</td>
<td>++、–</td>
<td>执行前置操作，变量的值在语句被求值以前更改 。执行后置操作时， 自增自减 在语句取值后执行。比如：++a +b  此时的a先自增再和b执行加法。a++ +b  先执行a+b， 而后a自增1。</td>
</tr>
<tr>
<td>一元加减操作符</td>
<td>+、-</td>
<td>用于基本算术运算</td>
</tr>
</tbody></table>
<p>位操作符</p>
<p>注意： 负数在计算中中用补码表示 （反码+1）</p>
<p>按位非 ~ （NOT）</p>
<p>按位与 &amp; （AND）</p>
<p>按位或 | （OR）</p>
<p>按位异或 ^ (XOR) 不同为1</p>
<p>左移 &lt;&lt;  右边加0 ,不影响操作数符号位</p>
<p>有符号右移 &gt;&gt; 右边删0,不影响操作数符号位</p>
<p>无符号右移 &gt;&gt;&gt;  右边删0,影响操作数符号位</p>
<p>布尔操作符</p>
<p>! 逻辑非 先转布尔再求反</p>
<p>​        返回true的值有：空字符串、数值0、null、NaN、undefined</p>
<p>​        返回false的值有：一个对象、非空字符串、任意非数值0、</p>
<p>&amp;&amp; 逻辑与 短路操作符</p>
<p>​        如果两操作数是对象，返回第二个操作数</p>
<p>​        如果第二个是对象，第一个为true 才返回该对象</p>
<p>​        如果第一个是对象，返回第二个操作数</p>
<p>​        如果第一个是null、NaN、Undefined， 分别返回null、NaN、Undefined</p>
<p>|| 逻辑或</p>
<p>​        如果第一个是对象，返回第一个操作数</p>
<p>​        如果两操作数是对象，返回第一个操作数</p>
<p>​        第一个操作数为false，才返回第二个操作数</p>
<p>​        如果两个都是null、NaN、Undefined， 才分别返回null、NaN、Undefined</p>
<p>乘性操作符</p>
<p>*乘</p>
<p>​        超出范围：Infinity、-Infinity</p>
<p>​        有一个是NaN,返回NaN</p>
<p>​        Infinity*0 = NaN</p>
<p>​        Infinity*非0 = Infinity / -Infinity</p>
<p>​        Infinity * Infinity = Infinity</p>
<p>​        如果有不是数值的数 后台会调用Number()</p>
<p>/除</p>
<p>​    超出范围：Infinity、-Infinity</p>
<p>​    如果有一个操作数是 NaN，则结果是 Nan;<br>​            如果是 Infinity 被 Infinity 除，则结果是NaN;<br>​            如果是零被零除，则结果是 naN<br>​            如果是非零的有限数被零除，则结果是 Infinity 或-Infinity，取决于有符号操作数的符号;</p>
<p>​    如果是Infinity 被任何非零数值除，则结果是Infinity 或-Infinity，取决于有符号操作数的符号;</p>
<p>​    如果有不是数值的数 后台会调用Number()</p>
<p>​        </p>
<p>%求余</p>
<p>​    如果操作数都是数值，执行常规的除法计算，返回除得的余数;</p>
<p>​    如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN;<br>​            如果被除数是有限大的数值而除数是零，则结果是 Nan;<br>​            如果是 Infinity 被 Infinity 除，则结果是 NaN;<br>​            如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;<br>​            如果被除数是零，则结果是零:<br>​            如果有不是数值的数 后台会调用Number()</p>
<p>加性操作</p>
<p>+加法</p>
<pre><code>+ 有一个操作数是 NaN，则结果是 NaN
+ Infinity  + Infinity = Infinity 
+ -Infinity + -Infinity  = -Infinity 
+ Infinity  + -Infinity  = NaN
+ +0 + +0 = +0
+ -0 + -0 = -0
+ +0 + -0 = +0
+ 如果有字符串 则都转换成字符串 ，拼接
+ 如果是对象、数值、布尔、undefined、 null 会调用tostring 方法再拼接</code></pre><p>-减法</p>
<ul>
<li><p>有一个操作数是 NaN，则结果是 NaN</p>
</li>
<li><p>Infinity  - Infinity = NaN</p>
<ul>
<li>-Infinity - -Infinity  = NaN</li>
<li>Infinity  - -Infinity  = Infinity  </li>
<li>-Infinity -Infinity   = -Infinity </li>
<li>+0 - +0 = +0</li>
<li>+0 - -0 = -0</li>
<li>-0 - -0 = -0</li>
<li>如有一个操作数是字符串布尔值nu11 或 defined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN;</li>
<li>如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueof )方法，则调用其 tostring()方法并将得到的字符串转换为数值。</li>
</ul>
</li>
</ul>
<p>关系操作符</p>
<p>​    &lt; &gt; &lt;= &gt;=</p>
<ul>
<li><p>任何操作数与NaN 比较 返回false</p>
</li>
<li><p>如果是数值 则比较</p>
</li>
<li><p>如果是字符串，比较字符编码值</p>
</li>
<li><p>如果有数值，都转为数值，然后比较</p>
</li>
<li><p>如果有对象 调用valueOf() 、没有则调用 toString()</p>
</li>
<li><p>如果有布尔值，转为数值后比较</p>
</li>
<li><p>字符串比较： 大写字母编码 &lt; 小于小写字母编码；同样是是小写的话，排在后面的更大；数值转成字符串比较，是比较的每一位，而不是整体 如”23” &lt; “3”; 字母与数字比较， number(字符串) = NaN ，数值与NaN 比较返回false。</p>
</li>
</ul>
<p>相等操作符</p>
<ul>
<li><p>== 和！=</p>
<p>强制转型；有布尔值 会先转成数值 false =&gt; 0 true =&gt; 1；有数值是字符串 先转数值； </p>
<p>有操作数是对象另一个不是，先调用valueOf() 再比较</p>
<ul>
<li>null == undefined // true</li>
<li>只要有NaN 相等操作 返回 false ，不等操作 返回 true。</li>
<li>如两个操作数都是对象，则比较它们是不是同一个对象。如两个操作数都指向同一个对象则相等操作符返回 true;否则，返回 false</li>
</ul>
</li>
<li><p>=== 和 ！== </p>
<p>类型和值都必须相等</p>
</li>
</ul>
<p>条件操作符 ？：</p>
<p>赋值操作符 = 或者是 复合赋值操作符 如乘性、加性、位操作</p>
<p>逗号操作符 </p>
<p>​    使用逗号操作符可以在一条语句中执行多个操作，如下面的例子所示:<br>​            var nun1-1num2=2， num3-3;<br>​            逗号操作符多用于声明多个变量;但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子所示:<br>​            var num = (5，1，4，8，0); // num 的值为0<br>​            由于0是表达式中的最后一项，因此 um 的值就是0。</p>
<p>​    </p>
<p>语句</p>
<ul>
<li><p>if</p>
</li>
<li><p>do {} while ()</p>
</li>
<li><p>while() {}</p>
</li>
<li><p>for(i, 条件 i++、–) {}</p>
</li>
<li><p>for(x in obj) 枚举对象的所有属性，先要检查 !== null | undefined</p>
</li>
<li><p>with（） {} 不建议使用 性能下降</p>
</li>
<li><p>switch() { case XX： break}</p>
</li>
<li><p>函数：函数参数使用数组来表示，所有参数传递的都是值么不能通过引用传递参数。所有修改了arguments 的值也不会变</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3></li>
</ul>
<p>参数内部用数组来表示，ecma 所有参数的传递都是值，不可能通过引用传递参数，因此修改了argumens 的值也不会变</p>
<p>函数没有重载，多次声明以最后一次声明为准。</p>
<h1 id="四-变量-作用域-内存问题"><a href="#四-变量-作用域-内存问题" class="headerlink" title="四. 变量 作用域 内存问题"></a>四. 变量 作用域 内存问题</h1><ul>
<li><p>变量</p>
<p>基本类型按值访问，引用类型按引用访问</p>
<p>引用类型可以添加、删除、改变其属性和方法。（只能给引用类型添加属性）</p>
<ul>
<li><p>复制：创新一个新值并为新变量分配该值。引用类型复制的实质上是指针。</p>
</li>
<li><p>传递参数：所有函数的参数都是按值传递的。引用类型复制的是一个。函数内部修改了参数的值，但原始的引用仍然保持不变。这个局部对象再函数执行完毕后立即被删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&#x27;init&#x27;</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&#x27;new&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>) <span class="comment">// init</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>检测类型 instanceof</p>
<p>引用类型 instanceof object  // true</p>
<p>基本类型 instanceof object  // false</p>
</li>
</ul>
<ul>
<li><p>执行环境： 只有两种类型 全局和局部(函数)</p>
<ul>
<li><p>作用域：</p>
</li>
<li><p>代码在环境中执行，会创建变量对象的一个作用域链；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
</li>
<li><p>内部环境可以访问作用域连访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数。</p>
<pre><code>+ 没有块级作用域，所以 **for循环声明的变量在执行完毕后依旧存在外部执行环境中**。ES6中 才有。
      + 查询标识符：向上逐级查询。</code></pre></li>
</ul>
</li>
<li><p>垃圾收集：js具有自动垃圾收集机制。</p>
<ul>
<li>标记清除：标记进入环境、离开环境（清除）</li>
<li>引用计数：各自属性相互引用，引用次数永远不等于0；BOM、DOM中对象使用COM(组件对象模型)实现，COM对象的垃圾收集机制采用引用计数策略。<strong>因此在不使用的时候，手动赋值null断开js对象与DOM元素之间的链接。</strong></li>
</ul>
</li>
<li><p>性能问题</p>
<ul>
<li>浏览器分配的内存数量比其他桌面应用少</li>
<li>优化内存的最佳方式：执行中的代码只保留必要的数据。不使用<strong>解除引用</strong>。<strong>及时解除全局对象、全局对象属性以及循环引用变量的引用</strong>。</li>
<li>解除引用不等于自动回收所占内存。真正意义是：<strong>让值脱离执行环境，以便垃圾收集器下次运行时将其收回</strong></li>
</ul>
</li>
<li><p><strong>作用域链增强</strong></p>
<ul>
<li>try/catch语句的catch块</li>
<li>with语句</li>
<li>这两种情况下，都会在作用域链前端添加一个变量对象。</li>
<li>对with语句来说，会向作用域链前端添加指定的对象</li>
<li>对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</li>
</ul>
</li>
</ul>
<h1 id="五-引用类型"><a href="#五-引用类型" class="headerlink" title="五. 引用类型"></a>五. 引用类型</h1><p>大多数引用类型值都是Object类型的实例</p>
<ul>
<li><p>Object类型</p>
<p>​    创建对象：new Object()、对象字面量 var person = {name: ‘jack’}</p>
<p>​    访问属性： <strong>点表示法 (建议)</strong> person.name 、 方括号表示法 person[‘name’]</p>
</li>
<li><p>Array 类型</p>
<p>创建数组 new Array(length| items)  可以省略new数组字面量</p>
<p>长度：操作length属性可以操作数组（新增或者删除项）</p>
<table>
<thead>
<tr>
<th>function</th>
<th>desc</th>
<th>分类</th>
</tr>
</thead>
<tbody><tr>
<td>Array.isArray()</td>
<td></td>
<td>检测数组</td>
</tr>
<tr>
<td>array.toString()</td>
<td>返回,拼接的字符串</td>
<td>转换数组（4）</td>
</tr>
<tr>
<td>array.toLocaleString()</td>
<td>返回,拼接的字符串</td>
<td>转换数组</td>
</tr>
<tr>
<td>array.valueOf()</td>
<td>返回,拼接的字符串</td>
<td>转换数组</td>
</tr>
<tr>
<td>array.join(连接符)</td>
<td>连接符拼接字符串</td>
<td>转换数组</td>
</tr>
<tr>
<td>array.push(item, item2,…)</td>
<td>添加至数组尾，返回length</td>
<td>栈方法（2）</td>
</tr>
<tr>
<td>array.pop()</td>
<td>移除数组最后一项，并返回</td>
<td>栈方法</td>
</tr>
<tr>
<td>array.unshift(item,item2,…)</td>
<td>添加至数组头部，返回length</td>
<td>队列方法（2）</td>
</tr>
<tr>
<td>array.shift()</td>
<td>移除数组第一项，并返回</td>
<td>队列方法</td>
</tr>
<tr>
<td>array.sort()</td>
<td>默认升序，比较前会先调用toString()方法。<br />接受函数，参数（value1，value2）<br />返回-1： value1,value2;返回1：value2，value1</td>
<td>重排序方法（2）</td>
</tr>
<tr>
<td>array.reverse()</td>
<td>反转数组顺序，并返回</td>
<td>重排序方法</td>
</tr>
<tr>
<td>array.concat(item| array)</td>
<td>合并，并返回新数组</td>
<td>操作方法（3）</td>
</tr>
<tr>
<td>array.slice(start，end[不含])</td>
<td>返回新数组，负数表示从尾部开始</td>
<td>操作方法</td>
</tr>
<tr>
<td>array.splice(index, dltNum, addItem,addItem2,… )</td>
<td>修改原来数组，返回删除的项</td>
<td>操作方法</td>
</tr>
<tr>
<td>array.indexOf(value)</td>
<td>返回查找项的数组下标，没有返回-1</td>
<td>位置方法（2）</td>
</tr>
<tr>
<td>array.lastIndexOf()</td>
<td>从数组末尾开始寻找，返回查找项的数组下标，没有返回-1</td>
<td>位置方法</td>
</tr>
<tr>
<td>every(function)</td>
<td>每一项返回true，则返回true</td>
<td>迭代方法（5个）</td>
</tr>
<tr>
<td>filter(function)</td>
<td>返回所有true的项组成的数组</td>
<td>迭代方法</td>
</tr>
<tr>
<td>forEach(function)</td>
<td>没有返回</td>
<td>迭代方法</td>
</tr>
<tr>
<td>map(function)</td>
<td>返回每项运行后结果组成的数组</td>
<td>迭代方法</td>
</tr>
<tr>
<td>some(function)</td>
<td>任一项返回true，则返回true</td>
<td>迭代方法</td>
</tr>
<tr>
<td>reduce(function， 归并初始值)</td>
<td>function接收4个参数 pre,cur,index,array</td>
<td>归并方法（2）</td>
</tr>
<tr>
<td>reduceRight(function， 归并初始值)</td>
<td>从数组末尾开始</td>
<td>归并方法</td>
</tr>
</tbody></table>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">valuel，value2</span>)(<span class="params"></span></span><br><span class="line"><span class="params">	<span class="keyword">return</span> value2 - valuel;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">arr.sort(compare)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span></span><br><span class="line"><span class="params"><span class="keyword">var</span> everyResult = numbers.every(<span class="keyword">function</span>(item,index,array)&#123;<span class="keyword">return</span> (item &gt; <span class="number">2</span>)&#125;)</span></span><br><span class="line"><span class="params">alert (everyResult);</span></span><br><span class="line"><span class="params"><span class="comment">//false</span></span></span><br><span class="line"><span class="params"><span class="keyword">var</span> someResult = numbers.some(<span class="keyword">function</span>(item, index，array)&#123;<span class="keyword">return</span> (item &gt; <span class="number">2</span>)&#125;)</span></span><br><span class="line"><span class="params">alert(someResult];</span></span><br><span class="line"><span class="params"><span class="comment">//true</span></span></span><br><span class="line"><span class="params">      </span></span><br><span class="line"><span class="params"><span class="keyword">var</span> mapResult = numbers.map(<span class="keyword">function</span>(item, index, array)&#123;<span class="keyword">return</span> item * <span class="number">2</span>&#125;)</span></span><br><span class="line"><span class="params">alert(mapResult)</span></span><br><span class="line"><span class="params"><span class="comment">// [2,,4,6,8,10,8,6,2]</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">使用 reduce()方法可以执行求数组中所有值之和的操作，比如</span></span><br><span class="line"><span class="params"><span class="keyword">var</span> values =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>，<span class="number">5</span>]</span></span><br><span class="line"><span class="params"><span class="keyword">var</span> sum = values.reduce(<span class="keyword">function</span>(prev, cur, index, array)&#123;</span></span><br><span class="line"><span class="params">    <span class="keyword">return</span>  prev + cur</span></span><br><span class="line"><span class="params">&#125;)</span></span><br><span class="line"><span class="params">alert(sum): <span class="comment">//15</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">var</span> values = [<span class="number">1.2</span><span class="number">.3</span>,<span class="number">4.5</span>]</span></span><br><span class="line"><span class="params"><span class="keyword">var</span> sum = values.reduceRight(<span class="keyword">function</span>(prev, cur, index, array)&#123;</span></span><br><span class="line"><span class="params">	<span class="keyword">return</span>  prev + cur</span></span><br><span class="line"><span class="params">&#125;)</span></span><br><span class="line"><span class="params">alert(sum); <span class="comment">//15</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>Date 类型</p>
<p>Date.parse(月日年) 返回毫秒数</p>
<p>Date.UTC(年月日时分秒) 返回毫秒数 这里的月是从0开始的</p>
<p>Date.now()返回毫秒数</p>
<p>Date.valueOf()返回毫秒数</p>
<p>new Date([年月日时分秒]) 这里的月是从0开始的</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>Eg</th>
</tr>
</thead>
<tbody><tr>
<td>toDateString()</td>
<td>以特定于实现的格式显示星期几、月、日和年</td>
<td>Thu Sep 07 2023</td>
</tr>
<tr>
<td>toTimeString()</td>
<td>以特定于实现的格式显示时、分、秒和时区</td>
<td>08:20:52 GMT+0800 (中国标准时间)</td>
</tr>
<tr>
<td>toLocaleDateString()</td>
<td>以特定于地区的格式显示星期儿、月、日和年;</td>
<td>2023/9/7</td>
</tr>
<tr>
<td>toLocaleTimeString()</td>
<td>以特定于实现的格式显示时、分、秒;</td>
<td>8:20:52</td>
</tr>
<tr>
<td>toUTCString()</td>
<td>以特定于实现的格式完整的 UTC日期</td>
<td>Thu, 07 Sep 2023 00:20:52 GMT</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td></td>
<td>2023/9/7 8:20</td>
</tr>
<tr>
<td>toString()</td>
<td></td>
<td>Thu Sep 07 2023 08:20:52 GMT+0800 (中国标准时间)</td>
</tr>
<tr>
<td>setTime(毫秒)</td>
<td>以毫秒数设置日期，会改变整个日期</td>
<td></td>
</tr>
<tr>
<td>getFullYear()</td>
<td>取得4位数的年份(如2007而非仅07 )</td>
<td></td>
</tr>
<tr>
<td>getUTCFullYear()</td>
<td>返回UTC日期的4位数年份</td>
<td></td>
</tr>
<tr>
<td>setFullYear(年)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>setUTCFullYear(年)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getMonth()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getUTCMonth()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>setMonth(月)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>setUTCMonth(月)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getDate()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getUTCDate()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>setDate()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>setUTCDate()</td>
<td></td>
<td></td>
</tr>
<tr>
<td>getDay()</td>
<td>从Date对象返回一周中的某一天（0~6）</td>
<td></td>
</tr>
<tr>
<td>getMonth()</td>
<td>从Date对象返回月份（0~11）</td>
<td></td>
</tr>
<tr>
<td>getFullYear()</td>
<td>从Date对象以4位数字返回年份</td>
<td></td>
</tr>
<tr>
<td>getYear()</td>
<td>请使用getFullYear()方法代替</td>
<td></td>
</tr>
<tr>
<td>getHours()</td>
<td>返回Date对象的小时（0~23）</td>
<td></td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回Date对象的分钟（0~59）</td>
<td></td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回Date对象的秒数（0~59）</td>
<td></td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回Date对象的毫秒（0~999）</td>
<td></td>
</tr>
<tr>
<td>getTime()</td>
<td>返回1970年1月1日至今的毫秒数,与valueof()方法返回的值相同</td>
<td></td>
</tr>
<tr>
<td>getTimezoneOffset()</td>
<td>返回本地时间与格林威治标准时间（GMT）的分钟差</td>
<td></td>
</tr>
<tr>
<td>getUTCDate()</td>
<td>根据世界时从Date对象返回月中的一天（1~31）</td>
<td></td>
</tr>
<tr>
<td>getUTCDay()</td>
<td>根据世界时从Date对象返回周中的一天（0~6）</td>
<td></td>
</tr>
<tr>
<td>getUTCMonth()</td>
<td>根据世界时从Date对象返回月份（0~11）</td>
<td></td>
</tr>
<tr>
<td>getUTCFullYear()</td>
<td>根据世界时从Date对象返回4位数的年份</td>
<td></td>
</tr>
<tr>
<td>getUTCHours()</td>
<td>根据世界时返回Date对象的小时（0~23）</td>
<td></td>
</tr>
<tr>
<td>getUTCMinutes()</td>
<td>根据世界时返回Date对象的分钟（0~59）</td>
<td></td>
</tr>
<tr>
<td>getUTCSeconds()</td>
<td>根据世界时返回Date对象的秒钟（0~59）</td>
<td></td>
</tr>
<tr>
<td>getUTCMilliseconds()</td>
<td>根据世界时返回Date对象的毫秒（0~999）</td>
<td></td>
</tr>
<tr>
<td>parse()</td>
<td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数</td>
<td></td>
</tr>
<tr>
<td>setDate()</td>
<td>设置Date对象中月的某一天（1~31）</td>
<td></td>
</tr>
<tr>
<td>setMonth()</td>
<td>设置Date对象中月份（0~11）</td>
<td></td>
</tr>
<tr>
<td>setFullYear()</td>
<td>设置Date对象中的年份（四位数字）</td>
<td></td>
</tr>
<tr>
<td>setYear()</td>
<td>请使用setFullYear()方法代替</td>
<td></td>
</tr>
<tr>
<td>setHours()</td>
<td>设置Date对象中的小时（0~23）</td>
<td></td>
</tr>
<tr>
<td>setMinutes()</td>
<td>设置Date对象中的分钟（0~59）</td>
<td></td>
</tr>
<tr>
<td>setSeconds()</td>
<td>设置Date对象中的秒钟（0~59）</td>
<td></td>
</tr>
<tr>
<td>setMiliseconds()</td>
<td>设置Date对象中的毫秒（0~999）</td>
<td></td>
</tr>
<tr>
<td>setTime(毫秒)</td>
<td>以毫秒设置Date对象,会改变整个日期</td>
<td></td>
</tr>
<tr>
<td>setUTCDate()</td>
<td>根据世界时设置Date对象中月份的一天（1~31）</td>
<td></td>
</tr>
<tr>
<td>setUTCMonth()</td>
<td>根据世界时设置Date对象中的月份（0~11）</td>
<td></td>
</tr>
<tr>
<td>setUTCFullYear()</td>
<td>根据世界时设置Date对象中的年份（四位数字）</td>
<td></td>
</tr>
<tr>
<td>setUTCHours()</td>
<td>根据世界时设置Date对象中的小时（0~23）</td>
<td></td>
</tr>
<tr>
<td>setUTCMinutes()</td>
<td>根据世界时设置Date对象中的分钟（0~59）</td>
<td></td>
</tr>
<tr>
<td>setUTCSeconds()</td>
<td>根据世界时设置Date对象中的秒钟（0~59）</td>
<td></td>
</tr>
<tr>
<td>setUTCMilliseconds()</td>
<td>根据世界时设置Date对象中的毫秒（0~999）</td>
<td></td>
</tr>
<tr>
<td>toSource()</td>
<td>返回该对象的源代码</td>
<td></td>
</tr>
<tr>
<td>toString()</td>
<td>把Date对象转换为字符串</td>
<td></td>
</tr>
<tr>
<td>toTimeString()</td>
<td>把Date对象的时间部分转换为字符串</td>
<td></td>
</tr>
<tr>
<td>toDateString()</td>
<td>把Date对象的日期部分转换为字符串</td>
<td></td>
</tr>
<tr>
<td>toGMTString()</td>
<td>请使用toUTCString()方法代替</td>
<td></td>
</tr>
<tr>
<td>toUTCString()</td>
<td>根据世界时，把Date对象转换为字符串</td>
<td></td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>根据本地时间格式，把Date对象转换为字符串</td>
<td></td>
</tr>
<tr>
<td>toLocaleTimeString()</td>
<td>根据本地时间格式，把Date对象的时间部分转换为字符串</td>
<td></td>
</tr>
<tr>
<td>toLocaleDateString()</td>
<td>根据本地时间格式，把Date对象的日期部分转换为字符串</td>
<td></td>
</tr>
<tr>
<td>UTC()</td>
<td>根据世界时返回1997年1月1日到指定日期的毫秒数</td>
<td></td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回Date对象的原始值</td>
<td></td>
</tr>
<tr>
<td>getTimezoneOffset()</td>
<td>返回本地时间与UTC时间相差的分钟数。例如，美国东部标准时间返300。在某地进人夏令时的情况下，这个值会有所变化</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>RegExp类型</p>
<ul>
<li><p>创建 正则表达式字面量 ：var expression = / pattern / flags 或者 new RegExp（”[bc]at”, “i”）</p>
<ul>
<li>flags （可组合）<ul>
<li>g 表示全局</li>
<li>i 表示不区分大小写</li>
<li>m 表示多行模式： 到达一行文本的末尾还会继续查找下一行受否存在与模式配置的项。</li>
</ul>
</li>
<li>pattern ( [ { } ] ) \ ^ $ | ? * +  . 要用转义<ul>
<li>. 除换行外的所有字符； ？0或1次 ；+ 最少一次； * 最少0次；</li>
<li>\d\w\s 数字\字符\空格  \D\W\S 非数字\非字符\非空格</li>
</ul>
</li>
</ul>
</li>
<li><p>RegBxp实例属性<br>global:布尔值，表示是否设置了 g 标志。<br>ignoreCase:布尔值，表示是否设置了 i标志。<br>latIndex;整数，表示开始搜索下一个匹配项的字符位置，从0算起<br>multiline:布尔值，表示是否设置了 m 标志。<br>ource:正则表达式的字符串表示</p>
</li>
<li><p>RegBxp实例方法</p>
<ul>
<li>exec() 每调用一次只返回一个匹配项</li>
<li>test() 返回true、false</li>
</ul>
</li>
<li><p>RegBxp构造函数属性</p>
<table>
<thead>
<tr>
<th>长性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串。Opera未实现此属性</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项。Opera未实现此属性</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组。Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本</td>
</tr>
<tr>
<td>multiline</td>
<td>$*</td>
<td>布尔值，表示是否所有表达式都使用多行模式。E和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>Input字符串中lastMatch之后的文本</td>
</tr>
<tr>
<td>9个匹配组</td>
<td>$1,…</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>Function 类型</p>
<ul>
<li><p>使用<strong>函数声明</strong>语法定义的：（函数声明提升，执行前先读取函数声明）<br>function sum (num1， num2) { return num1 + num2 ; }<br>使用<strong>函数表达式</strong>定义函数（拉姆达函数，使用前先赋值）<br>var sum = function(num1，num2){ return numl + num2 ;}</p>
</li>
<li><p>没有重载： 声明了两个同名函数，是后面的函数覆盖了前面的函数</p>
</li>
<li><p>解析器在向执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问 );至于数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
</li>
<li><p><strong>作为值的函数</strong><br>因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callSomeFunction</span>(<span class="params">someFunction，someArgument</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">someFunction</span>(someArgument) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add10</span>(<span class="params">num</span>)&#123; <span class="keyword">return</span> num + <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result1 = <span class="title function_">callSomeFunction</span>(add10， <span class="number">10</span>);</span><br><span class="line"><span class="title function_">alert</span>(result1);<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1， object2</span>)(<span class="params"></span></span><br><span class="line"><span class="params">		<span class="keyword">var</span> value1 = object1[propertyNamel;</span></span><br><span class="line"><span class="params">		<span class="keyword">var</span> value2 = object2[propertyName];</span></span><br><span class="line"><span class="params">		<span class="keyword">if</span> (valuel &lt; value2)&#123;</span></span><br><span class="line"><span class="params">			<span class="keyword">return</span> -<span class="number">1</span>;</span></span><br><span class="line"><span class="params">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (valuel &gt; value2)&#123;</span></span><br><span class="line"><span class="params">			<span class="keyword">return</span> <span class="number">1</span>;</span></span><br><span class="line"><span class="params">		&#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="params">			<span class="keyword">return</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="params">        &#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">var</span> data =[(name:<span class="string">&quot;Zachary&quot;</span>，age: <span class="number">28</span>)，(name:<span class="string">&quot;Nicholas&quot;</span>，age:<span class="number">29</span>)];</span></span><br><span class="line"><span class="params">data.sort(createComparisonFunction(<span class="string">&quot;name&quot;</span>));</span></span><br><span class="line"><span class="params">alert(data(<span class="number">0</span>].name);  <span class="comment">//Nicholas</span></span></span><br><span class="line"><span class="params">data.sort(createComparisonFunction(*age<span class="string">&quot;));</span></span></span><br><span class="line"><span class="string"><span class="params">alert(data[0].name);  //Zachary</span></span></span><br><span class="line"><span class="string"><span class="params">      </span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数内部属性</p>
<ul>
<li>arguments</li>
<li>this：this引用的是函数据以执行的环境对象</li>
</ul>
</li>
<li><p><strong>函数属性和方法</strong></p>
<ul>
<li>length属性：表示函数希望接收的命名参数的个数</li>
<li><strong>prototype</strong>属性： 不可枚举属性，使用for in 不能访问</li>
<li>每个函数都包含两个非继承而来的方法:apply() call()； bind()会建一个函数的实例，</li>
<li>每个函数继承的toLocalestring()和 tostring()方法始终都返回函数的代码。</li>
</ul>
</li>
</ul>
</li>
<li><p>基本包装类型</p>
<p>3个特殊的引用类型 Boolean、Number、String 后台会创建一个对应的基本包装类型的对象</p>
<ul>
<li><p>引用类型 Boolean </p>
<p>Boolean类型的实例重写了valueof()方法返回基本类型值true或false;重写了tostring()方法，返回字符串”true”和”alse”。</p>
<p> typeof =&gt; object ,Boolean 对象 = true</p>
</li>
<li><p>Number 类型</p>
<p>重写了valueof()：返回对象表示的基本类型的数值；toLocaleString()和toString()返回对象表示的基本类型的数值<br>tofixed（小数位数）：按照指定的小数位返回数值的字符串表示</p>
<p> toExponential(指数幂)：返回以指数表示法(也称表示法)表示的数值的字符串形式。</p>
</li>
<li><p>String类型</p>
<table>
<thead>
<tr>
<th>字符方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>chartAt（number）</td>
<td>给定位置的字符</td>
</tr>
<tr>
<td>chartCodeAt（number）</td>
<td>给定位置的字符编码</td>
</tr>
<tr>
<td>stringValue（number）</td>
<td>同chartAt（）</td>
</tr>
<tr>
<td>字符串操作方法</td>
<td></td>
</tr>
<tr>
<td>concat（）</td>
<td>返回拼接后的字符串</td>
</tr>
<tr>
<td>slice（开始位置，返回字符位置、不含）</td>
<td>返回新字符串</td>
</tr>
<tr>
<td>substr(开始位置，返回字符位置、不含)</td>
<td>返回新字符串</td>
</tr>
<tr>
<td>substring(开始位置，返回字符个数)</td>
<td>返回新字符串</td>
</tr>
<tr>
<td>字符串位置方法</td>
<td></td>
</tr>
<tr>
<td>indexOf()</td>
<td></td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>最后一次 出现位置</td>
</tr>
<tr>
<td>trim（）</td>
<td>返回删除前后空格字符串</td>
</tr>
<tr>
<td>大小写转换</td>
<td></td>
</tr>
<tr>
<td>toLowerCase</td>
<td></td>
</tr>
<tr>
<td>toUpperCase</td>
<td></td>
</tr>
<tr>
<td>toLocalLowerCase</td>
<td></td>
</tr>
<tr>
<td>toLocalUpperCase</td>
<td></td>
</tr>
<tr>
<td>字符串的模式匹配：部分见regExp</td>
<td></td>
</tr>
<tr>
<td>match()</td>
<td>function htmlEscape(text){return text,replace(/[&lt;&gt;”&amp;]/g，function(match，pos,originalText){switch(match)(<br/>Case #&lt;”:<br/>return “&lt;”;<br/>Case “&gt;”:<br/>return “&gt;”;<br/>case “&amp;”:<br/>return”&amp;”;Case sinw <br/>return “&quot;.;<br/>alert(htmlEscape(<p class="greeting)">Hello world!</p>“));//&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;</td>
</tr>
<tr>
<td>replace(string, string| function)</td>
<td>var text =“cat, bat, sat, fat”;<br/>result = text.replace(/(.at)/g<br/>alert(result);<br/>//word (cat)<br/>nword (1)”);<br/>word (bat)，word (sat), word (fat)</td>
</tr>
<tr>
<td>split(分割符，[返回数组长度])</td>
<td>返回数组</td>
</tr>
<tr>
<td>localeCompare(string)</td>
<td>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数(大多数情况下是-1，具体的值要视实现而定);<br/>如果字符串等于字符串参数，则返回 0:<br/>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数(大多数情况下是 1具体的值同样要视实现而定)。</td>
</tr>
<tr>
<td>fromChartCode(i1,i2,…)</td>
<td>将字符编码转为字符串</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>单体内置对象</p>
<ul>
<li><p>Global对象</p>
<table>
<thead>
<tr>
<th>Global方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>encodeURI</td>
<td>只对空格编码 %20</td>
</tr>
<tr>
<td>encodeURIComponent</td>
<td>对所有非字符数字编码</td>
</tr>
<tr>
<td>decodeURI</td>
<td>解码</td>
</tr>
<tr>
<td>decodeURIComponent</td>
<td>解码</td>
</tr>
<tr>
<td>eval</td>
<td>ecma解析器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Global对象所有属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>undefined</td>
<td>特殊值undefined</td>
</tr>
<tr>
<td>NaN</td>
<td>特殊值NaN</td>
</tr>
<tr>
<td>Infinity</td>
<td>特殊值Infinity</td>
</tr>
<tr>
<td>Object</td>
<td>Object的构造函数</td>
</tr>
<tr>
<td>Array</td>
<td>Array的构造函数</td>
</tr>
<tr>
<td>Function</td>
<td>Function的构造函数</td>
</tr>
<tr>
<td>Boolean</td>
<td>Boolean的构造函数</td>
</tr>
<tr>
<td>String</td>
<td>String 的构造函数</td>
</tr>
<tr>
<td>Number</td>
<td>Number 的构造函数</td>
</tr>
<tr>
<td>Date</td>
<td>Date的构造函数</td>
</tr>
<tr>
<td>RegExp</td>
<td>RegExp的构造函数</td>
</tr>
<tr>
<td>Symbol</td>
<td>Symbol的伪构造函数</td>
</tr>
<tr>
<td>Error</td>
<td>Error 的构造函数</td>
</tr>
<tr>
<td>EvalError</td>
<td>EvalError 的构造函数</td>
</tr>
<tr>
<td>RangeError</td>
<td>RangeError的构造函数</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>SyntaxError的构造函数</td>
</tr>
<tr>
<td>TypeError</td>
<td>TypeError的构造函数</td>
</tr>
<tr>
<td>URIError</td>
<td>URIError的构造函数</td>
</tr>
</tbody></table>
</li>
<li><p>window对象 Gobal的直接访问由window 实现</p>
</li>
<li><p>Math对象</p>
<table>
<thead>
<tr>
<th>Math 对象的属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>E</td>
<td>返回算术常量 e，即自然对数的底数（约等于2.718）。</td>
</tr>
<tr>
<td>LN2</td>
<td>返回 2 的自然对数（约等于0.693）。</td>
</tr>
<tr>
<td>LN10</td>
<td>返回 10 的自然对数（约等于2.302）。</td>
</tr>
<tr>
<td>LOG2E</td>
<td>返回以 2 为底的 e 的对数（约等于 1.414）。</td>
</tr>
<tr>
<td>LOG10E</td>
<td>返回以 10 为底的 e 的对数（约等于0.434）。</td>
</tr>
<tr>
<td>PI</td>
<td>返回圆周率（约等于3.14159）。</td>
</tr>
<tr>
<td>SQRT1_2</td>
<td>返回返回 2 的平方根的倒数（约等于 0.707）。</td>
</tr>
<tr>
<td>SQRT2</td>
<td>返回 2 的平方根（约等于 1.414）。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Math.min()</td>
<td></td>
</tr>
<tr>
<td>Math.max()</td>
<td></td>
</tr>
<tr>
<td>Math.ceil()</td>
<td>向上舍入</td>
</tr>
<tr>
<td>Math.floor()</td>
<td>向下舍入</td>
</tr>
<tr>
<td>Math.round()</td>
<td>标准舍入</td>
</tr>
<tr>
<td>Math.random()</td>
<td>返回一个&gt;=0 &lt;1的随机数</td>
</tr>
<tr>
<td>Math.abs(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>Math.exp(x)</td>
<td>返回Math.E的x次幂</td>
</tr>
<tr>
<td>Math.expm1(x)</td>
<td>等于Math.exp(x) -1</td>
</tr>
<tr>
<td>Math.log(x)</td>
<td>返回x的自然对数</td>
</tr>
<tr>
<td>Math.log1p</td>
<td>等于1 + Math.log(x)</td>
</tr>
<tr>
<td>Math.pow(x,power)</td>
<td>返回x的power次幂</td>
</tr>
<tr>
<td>Math.hypot(..nums)</td>
<td>返回nums中每个数平方和的平方根</td>
</tr>
<tr>
<td>Math.clz32(x)</td>
<td>返回32位整数x的前置零的数量</td>
</tr>
<tr>
<td>Math.sign(x)</td>
<td>返回x符号的1，0，-0或 -1</td>
</tr>
<tr>
<td>Math.trunc(x)</td>
<td>返回x的整数部分，删除所有小数</td>
</tr>
<tr>
<td>Math.sqrt(x)</td>
<td>返回x的平方根</td>
</tr>
<tr>
<td>Math.cbrt(x)</td>
<td>返回x的立方根</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x的反余弦</td>
</tr>
<tr>
<td>Math.acosh(x)</td>
<td>返回x的反双曲余弦</td>
</tr>
<tr>
<td>Math.asin(x)</td>
<td>返回x的反正弦</td>
</tr>
<tr>
<td>Math.asinh(x)</td>
<td>返回x的反双曲正弦</td>
</tr>
<tr>
<td>Math.atan(x)</td>
<td>返回x的反正切</td>
</tr>
<tr>
<td>Math.atanh(x)</td>
<td>返回x的反双曲正切</td>
</tr>
<tr>
<td>Math.atan2(y,x)</td>
<td>返回y/x的反正切</td>
</tr>
<tr>
<td>Math.cos(x)</td>
<td>返回x的余弦</td>
</tr>
<tr>
<td>Math.sin(x)</td>
<td>返回x的正弦</td>
</tr>
<tr>
<td>Math.tan(x)</td>
<td>返回x的正切</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    返回true：</p>
<p>​    返回false：</p>
<h1 id="六-面向对象的程序设计"><a href="#六-面向对象的程序设计" class="headerlink" title="六. 面向对象的程序设计"></a>六. 面向对象的程序设计</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>属性类型：（两种）</p>
<ul>
<li><p>数据属性：包含有特性以下：</p>
<ul>
<li><p>configurable,设置为false 表示不能从对象中删除属性</p>
</li>
<li><p>enumberable,能否通过for-in循环返回属性</p>
</li>
<li><p>writable,设置为false表示是只读的</p>
</li>
<li><p>value，默认undefined</p>
<p><strong>不指定情况下configurable,enumberable,writable这三个属性都是默认为false.</strong></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>访问器属性：包含有特性以下：</p>
<ul>
<li>configurable,设置为false 表示不能从对象中删除属性，默认true</li>
<li>enumberable,能否通过for-in循环返回属性，默认true</li>
<li>get:读取属性调用的函数，默认undefined</li>
<li>set：写入属性调用的函数，默认undefined</li>
</ul>
</li>
<li><p>定义属性：Object.defineProperty(对象，属性，值)</p>
</li>
<li><p>定义多个属性：Object.defineProperties(对象，值)</p>
</li>
<li><p>读取属性的特征：Object.getOwnPropertyDescriptor(对象，属性名)</p>
</li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li><p><strong>工厂模式</strong></p>
<p>用函数开封装以特定接口创建对象的细节。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决创建多个相似对象问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">job</span> = job;</span><br><span class="line"></span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="title class_">Person</span>(<span class="string">&#x27;李雪峰&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;web前端开发&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="title class_">Person</span>(<span class="string">&#x27;hq&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;摄影师&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数模式</p>
<p>构造函数用new创建新对象</p>
<p>每一个实例的同名函数不相等</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name,color</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;旺财&#x27;</span>,<span class="string">&#x27;黑色&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;阿拉斯加&#x27;</span>,<span class="string">&#x27;黑白相间&#x27;</span>)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>原型模式</strong></p>
<p>protype原型属性，是一个指针，指向一个对象，而这个对象的用途是包含由特定类型的所有实例共享的属性和方法。</p>
<p>通过调用构造函数而创建的那个对象实例的原型对象。</p>
<p>创建一个新函数：创建一个prototype属性，指向函数的原型对象。</p>
<p>默认情况下，所以原型对象都会自动获得一个constructor(构造函数)属性指向prototype属性所在函数的指针。【原型对象的constructor属性指向创建该对象的构造函数。】</p>
<p>实例内部prototype指针指向构造函数的原型对象。构造函数protype指向原型对象。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1315889-5abbaf27d31688e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/771/format/webp" alt="img"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断对象之间是否存在原型关系：[[Prototype]]指向调用isPrototypeOf()方法的对象Person.prototype，则会返回true。</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">protype</span>.<span class="title function_">isPrototypeOf</span>(person1) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 返回对象原型</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(person1) == <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;旺财&quot;</span>;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">3</span>;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line">dog.<span class="title function_">sayName</span>();   <span class="comment">//旺财</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog2 = <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line"></span><br><span class="line">dog2.<span class="title function_">sayName</span>();   <span class="comment">//旺财</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">sayName</span> === dog2.<span class="property">sayName</span>)   <span class="comment">//true</span></span><br><span class="line">dog2.<span class="title function_">hasOwnProperty</span>(name) <span class="comment">// false</span></span><br><span class="line"><span class="title function_">hasPrototypePrototype</span>(dog2, name) <span class="comment">// true</span></span><br><span class="line">dog2.<span class="property">name</span> = <span class="string">&#x27;旺财2&#x27;</span></span><br><span class="line">dog2.<span class="title function_">hasOwnProperty</span>(name) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">hasPrototypePrototype</span>(dog2, name) <span class="comment">// false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象实例设置属性，可以屏蔽访问原型对象中同名属性。delete 属性可以删除实例属性。</p>
<ul>
<li><p>hasOwnProperty()可以检测一个属性是否存在于实例（是否实例属性）</p>
</li>
<li><p>in： 通过对象能够访问的属性返回true。（无论是在实例或者在原型上能访问都是返回true）</p>
</li>
<li><p>for-in 循环返回所有能够通过对象访问的，可枚举的属性</p>
</li>
<li><p>hasPrototypePrototype() : 属性存在原型中返回true</p>
</li>
<li><p>Object.keys() 返回数组，对象上所有可枚举的实例属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title function_">alert</span>(keys); <span class="comment">//&quot;name,age,job,sayName&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&quot;Rob&quot;</span>;</span><br><span class="line">p1.<span class="property">age</span> = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">var</span> p1keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(p1);</span><br><span class="line"><span class="title function_">alert</span>(p1keys); <span class="comment">//&quot;name,age&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.getOwnPropertyNames</code>会得到所有实例属性，不论是否可枚举。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype);</span><br><span class="line">alert(keys); <span class="comment">//&quot;constructor,name,age,job,sayName&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>简单的原型语法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">      name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">      age : <span class="number">29</span>,</span><br><span class="line">      <span class="attr">job</span>: <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">      sayName : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 这样写有一个缺陷，constructor属性则会等于Object，我们需要手动设置constructor</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">      <span class="comment">// consturctor:Person, // 重设consturctor属性导致Enumberable为true，默认应该是不可枚举的。采用下面的方法</span></span><br><span class="line">      name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">      age : <span class="number">29</span>,</span><br><span class="line">      job : <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">      sayName : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">          <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="title class_">Person</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>原型的动态性：如果重写整个原型对象会导致构造函数与最初原型之间的联系切断。实例中的指针只指向原型不指向构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person();</span><br><span class="line">Person.prototype = &#123;  //重写</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name : &quot;Nicholas&quot;,</span><br><span class="line">    age : 29,</span><br><span class="line">    job : &quot;Software Engineer&quot;,</span><br><span class="line">    sayName : function () &#123;</span><br><span class="line">        alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayName(); //error</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1315889-e77b2c4df48af9ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/803/format/webp" alt="img"></p>
</li>
<li><h4 id="结合使用构造函数和原型模式"><a href="#结合使用构造函数和原型模式" class="headerlink" title="结合使用构造函数和原型模式"></a>结合使用构造函数和原型模式</h4><p>用构造函数模式定义实例属性，用原型模式定义方法和共享属性</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    constructor : <span class="title class_">Person</span>,</span><br><span class="line">    sayName : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"></span><br><span class="line">person1.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Van&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count,Van&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(person2.<span class="property">friends</span>); <span class="comment">//&quot;Shelby,Count&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">friends</span> === person2.<span class="property">friends</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">sayName</span> === person2.<span class="property">sayName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>动态原型模式</strong><br> 可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">sayName</span> != <span class="string">&quot;function&quot;</span>) &#123; <span class="comment">//在sayName()方法不存在的情况下，才会将它添加到原型中。instanceof操作符也可以</span></span><br><span class="line">        <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nike&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Engineer&quot;</span>);</span><br><span class="line">friend.<span class="title function_">sayName</span>();<span class="comment">//Nike</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>寄生构造函数模式</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    o.<span class="property">name</span> = name;</span><br><span class="line">    o.<span class="property">age</span> = age;</span><br><span class="line">    o.<span class="property">job</span> = job;</span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比工厂模式多了个new调用, 并且把Person叫做了构造函数</span></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;李学峰&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;web前端开发&#x27;</span>);</span><br><span class="line">friend.<span class="title function_">sayName</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SpecialArray</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="comment">//添加值</span></span><br><span class="line"></span><br><span class="line">    values.<span class="property">push</span>.<span class="title function_">apply</span>(values,<span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    values.<span class="property">toPipedString</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&#x27;||&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回数组</span></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="title class_">SpecialArray</span>(<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;pink&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors.<span class="title function_">toPipedString</span>());    <span class="comment">//red||pink||orange||blue</span></span><br></pre></td></tr></table></figure>

<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><blockquote>
<ul>
<li>变量Person中保存的是一个稳妥对象,而除了调用sayName()</li>
<li>没有别的方式可以访问其数据成员.</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">复制代码<span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name,age,job</span>)&#123;</span><br><span class="line">    <span class="comment">// 创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line">    o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="title class_">Person</span>(<span class="string">&#x27;lxf&#x27;</span>,<span class="string">&#x27;111&#x27;</span>,<span class="string">&#x27;web&#x27;</span>);</span><br><span class="line">friend.<span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>接口继承和实现继承.接口继承只继承方法签名，实现继承继承实际的方法。</li>
<li>ECMAScript只支持实现继承,而且其实现继承的主要是依靠<strong>原型链</strong>来实现的</li>
<li>原型链的概念</li>
</ul>
<blockquote>
<p>原型链的概念: 其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法</p>
</blockquote>
<blockquote>
<p>每个构造函数都有一个<code>原型对象</code>,原型对象都包含一个<code>指向构造函数的指针 constructor</code>,而<code>实例</code>都包含一个<code>指向原型对象的内部指针[[proto]](__proto__)</code>.</p>
</blockquote>
<blockquote>
<p>假如我们让<code>原型对象</code>等于另一个类型的<code>实例</code>,结果就是,此时的<code>原型对象</code>将包含<code>一个指向另一个原型的指针</code></p>
</blockquote>
<blockquote>
<p>假如另一个<code>原型</code>又是另一个<code>类型</code>的实例,那么上述关系依然成立,如此层层递进,就构成了<code>实例与原型的链条</code>. <strong>这就是所谓原型链的基本概念</strong></p>
</blockquote>
<ul>
<li>引用类型默认继承Object</li>
</ul>
<p><code>实际上</code>,不是SubType的原型的 constructor 属性被重写了,<code>而是 SubType 的原型指向了另一个对象 SuperType 的原型</code>,而这个原型对象的 constructor 属性指向的是 SuperType</p>
<p>确定原型和实例的关系：</p>
<ul>
<li><p>使用 <code>instanceof</code> 操作符，这个操作符来测试实例与原型中出现过的构造函数,结果就会返回true</p>
</li>
<li><p><code>isPrototypeOf()方法</code>，只要是<code>原型链中出现过的原型</code>,都可以说是该<code>原型链所派生的实例的原型</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(instance instanceof Object);    //true</span><br><span class="line">console.log(instance instanceof SubType);    //true</span><br><span class="line">console.log(instance instanceof SuperType);    //true</span><br><span class="line"></span><br><span class="line">console.log(Object.isPrototypeOf(instance));    // true</span><br><span class="line">console.log(SuperType.isPrototypeOf(instance)); // true</span><br><span class="line">console.log(SubType.isPrototypeOf(instance));   // true</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/16/162cecd821c139ae~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="完整的原型链"></p>
<ul>
<li><p>通过原型链实现继承时，不能使用对象字面量创建原型方法，否则回重写原型链。</p>
</li>
<li><p>原型链的问题：</p>
<ul>
<li>一个是通过原型来实现继承时,包含引用类型值的原型,会共享</li>
<li>一个是: 在创建子类型的实例时,不能向超类型的构造函数中传递参数。<strong>实践中很少会单独使用原型链</strong></li>
</ul>
<h3 id="借用构造函数（constructor-stealing）"><a href="#借用构造函数（constructor-stealing）" class="headerlink" title="借用构造函数（constructor stealing）"></a>借用构造函数（constructor stealing）</h3><p>又叫“伪造对象”或“经典继承”。<br><strong>基本思想</strong><br>在子类型构造函数的内部调用超类型构造函数。函数只不过是在特定环境中执行代码的对象，因此通过使用 apply() 和 call() 也可以在（将来）新创建的对象上执行构造函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">&quot;red&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 继承了 A</span></span><br><span class="line">    A.call(<span class="keyword">this</span>); <span class="comment">// 🔑✔</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> B();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">// &quot;red, blue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> B();</span><br><span class="line">alert(instance2.colors); <span class="comment">// &quot;red&quot;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="1-传递参数"><a href="#1-传递参数" class="headerlink" title="1. 传递参数"></a>1. 传递参数</h4><p>相对于原型链而言，借用构造函数有一个很大的有时，可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span><span class="params">(name)</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 继承了 A</span></span><br><span class="line">    A.call(<span class="keyword">this</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> B();</span><br><span class="line">alert(instance1.name); <span class="comment">// &quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>

<p>为了确保 A 构造函数不会重写子类型的属性，可以在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p>
<h4 id="2-借用构造函数的问题"><a href="#2-借用构造函数的问题" class="headerlink" title="2. 借用构造函数的问题"></a>2. 借用构造函数的问题</h4><ol>
<li>方法都在构造函数中定义，因此函数复用就无从谈起；</li>
<li>在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。<strong>因此借用构造函数也很少单独使用</strong>。</li>
</ol>
<h3 id="组合继承（combination-inheritance）（常用继承模式）"><a href="#组合继承（combination-inheritance）（常用继承模式）" class="headerlink" title="组合继承（combination inheritance）（常用继承模式）"></a>组合继承（combination inheritance）（常用继承模式）</h3><p>又叫“伪经典继承”，组合了原型链继承和借用构造函数继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都拥有自己的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    A.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 第二次调用 A</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">A</span>(); <span class="comment">// 第一次调用 A</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = B; <span class="comment">// 实例赋值给原型</span></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> <span class="title function_">B</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">22</span>);</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red, blue&quot;</span></span><br><span class="line">instance1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Jack&quot;</span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>(); <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> <span class="title function_">B</span>(<span class="string">&quot;Nick&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="title function_">alert</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red&quot;</span></span><br><span class="line">instance2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nick&quot;</span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>(); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JS中最常用的继承模式。而且，<strong>instanceof 和 isPropertyOf()</strong> 也能够用于识别基于组合继承创建的对象。</p>
<p><strong>组合模式的问题</strong></p>
<p>无论什么情况下，都会<strong>调用两次超类型构造函数</strong>：一次是在创建子类型原型的时候，一次是在子类型构造函数内部。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">object</span>(o) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title">F</span>()&#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原型式继承要求必须有一个对象作为另一个对象的基础。这个对象是共享的</p>
<p>ECMAScript 5 中新增了 Object.create() 来规范原型式继承。接收2个参数：1、一个用做新对象原型的对象；2、（可选）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create() 和 object() 的行为相同。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person <span class="operator">=</span> &#123;&#125;<span class="comment">;</span></span><br><span class="line">var anotherPerson <span class="operator">=</span> Object.create(person)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>如果只想让一个对象与另一个对象保持类似的情况下，原型式继承完全可以胜任。但是包含引用类型值的属性始终都会共享相应的值，这点与原型模式一样。</p>
<h3 id="寄生式继承（parasitic）"><a href="#寄生式继承（parasitic）" class="headerlink" title="寄生式继承（parasitic）"></a>寄生式继承（parasitic）</h3><p>它的思路与寄生构造函数和工厂模式相似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">clone</span> = <span class="keyword">object</span>(original); <span class="comment">// 通过调用函数创建一个新对象 返回一个传入对象的新的实例赋值给</span></span><br><span class="line">    <span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 以某种方式增强对象</span></span><br><span class="line">        <span class="title function_ invoke__">alert</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">clone</span>; <span class="comment">// 返回对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    friends: [<span class="string">&quot;Nick&quot;</span>, <span class="string">&quot;Tony&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_ invoke__">createAnother</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_ invoke__">sayHi</span>(); <span class="comment">// &quot;Hi&quot;</span></span><br></pre></td></tr></table></figure>

<p>新对象不仅具有 person 的所有属性和方法，还有自己的方法。</p>
<p>在主要考虑“对象”而不是“自定义类型”和“构造函数”的情况下，寄生式继承也是一种有用的模式。object() 并不是必需的；任何能够返回新对象的函数都适用于该模式。</p>
<p>注意：使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</p>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>本质上，就是使用“寄生式继承”来继承超类型的原型，再将结果指定给子类型的原型。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function inheritPrototype(<span class="function"><span class="keyword">sub</span>, <span class="title">super</span>) </span>&#123;</span><br><span class="line">    var <span class="keyword">prototype</span> = Object(super); <span class="regexp">//</span> 创建对象</span><br><span class="line">    prototype.constructor = <span class="function"><span class="keyword">sub</span></span>; // 增强对象</span><br><span class="line">    sub.prototype = <span class="keyword">prototype</span>; <span class="regexp">//</span> 指定对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建超类型原型的一个副本；</li>
<li>为创建的副本添加 constructor 属性，从而弥补因【重写原型】而失去的默认的 constructor 属性；</li>
<li>将新创建的对象（即副本）赋值给子类型的原型。</li>
</ol>
<p>修改之前的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params">age</span>) &#123;</span><br><span class="line">    A.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(B,A);</span><br><span class="line"></span><br><span class="line">B.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模式的高效率体现在它只调用了一次 A 构造函数，并且因此避免了在 B 的 prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf() 方法。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h1 id="七-函数表达式"><a href="#七-函数表达式" class="headerlink" title="七.函数表达式"></a>七.函数表达式</h1><p>由于有声明提升的存在，定义函数不要放在条件表达式中</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">sayHi</span> () &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<strong>ECMAScript</strong>中属于无效语法，在不同浏览器中修正的做法并不一致。推荐的写法，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sayHi = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种<strong>函数表达式不存在声明提升</strong>，所以OK。</p>
<p>JavaScript函数表达式具有以下特征：</p>
<ol>
<li>匿名性：函数表达式可以是匿名的，也就是没有函数名。这意味着函数只能通过变量来引用，而不是通过函数名。</li>
<li>变量赋值：函数表达式将一个函数赋值给一个变量。这意味着可以将函数作为变量传递给其他函数或存储在数据结构中。</li>
<li>作用域：函数表达式可以在特定的作用域中定义函数，使其具有封闭的作用域。这使得函数内部的变量无法从外部访问。</li>
<li>函数提升：与函数声明不同，函数表达式不会发生函数提升。如果在函数表达式之前调用该函数，会导致未定义的错误。</li>
<li>立即执行函数：函数表达式可以立即执行，即在定义后立即调用。这种模式常用于创建私有作用域和避免全局变量污染。</li>
<li>高阶函数：函数表达式可以作为参数传递给其他函数，也可以作为其他函数的返回值。这种能力使得函数表达式可以用来实现高阶函数。</li>
</ol>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>函数通过名字调用自身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n * <span class="title function_">factorial</span>(n-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arguments.callee()</p>
<p>指针：指向正在执行的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式下</span></span><br><span class="line"><span class="comment">// var factorial = (function f(n)&#123; if ... &#125;)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(num&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(n-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<ul>
<li><strong>闭包与变量</strong></li>
</ul>
<p>闭包只能取得包含函数中任何变量的最后一个值。</p>
<p>闭包保存的是整个变量对象，而不是某个特殊的变量</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createArr()&#123;</span><br><span class="line">	var res = new Array();</span><br><span class="line">	for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">		res[i] = function()&#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createArr()[0](); //10 每个函数返回的都是10</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong></p>
<p>没有直接把闭包赋值给数组，而是定义了一个匿名函数，</p>
<p>并立即执行匿名函数，将结果赋值给数组</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createArr()&#123;</span><br><span class="line">	var res = new Array();</span><br><span class="line">	for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">		res[i] = (function(num)&#123;</span><br><span class="line">			return function()&#123;</span><br><span class="line">				return num;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;)(i);</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">createArr()[0](); //0</span><br></pre></td></tr></table></figure>

<ul>
<li>this 对象：匿名函数的执行环境具有全局性，容易发生改变，因此其this对象通常指向window</li>
</ul>
<p>每个函数在被调用时都会自动获取两个特殊的变量：this和arguments，内部函数搜索到这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量，但是把外部作用域中的this对象保存在一个闭包能够访问的变量里，就可以让闭包访问该对象了</p>
<p><strong>解决：</strong></p>
<p>把外部作用域中的this对象保存在一个闭包能够访问的变量里。</p>
<p>arguments也同理。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;window&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	name:&quot;obj&quot;;</span><br><span class="line">	getName:function()&#123;</span><br><span class="line">		var that = this; //保存在一个闭包能够访问的变量里</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		return function()&#123;   //闭包</span><br><span class="line">			return that.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj.getName()(); //&quot;obj&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>内存泄漏，需要将其释放</p>
<p>原因：JScript对象和COM对象使用不同的垃圾收集例程（IE9之前版本）</p>
<p>结果：闭包在IE9之前的版本，如果闭包的作用域链中保存着一个HTML元素，该元素将会无法被销毁。</p>
<p><strong>解决：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandler</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;ele&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> id = element.<span class="property">id</span>;</span><br><span class="line">	element.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;  <span class="comment">//闭包</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">	&#125;</span><br><span class="line">	element = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解除对DOM对象的引用，减少引用数，确保正常回收其占用的内存。</p>
<ol>
<li><p>把element.id保存在一个变量中，在闭包中引用该变量，消除了循环引用。</p>
</li>
<li><p>element设置为null。闭包会引用外部函数的整个活动对象，即使闭包不直接引用element，</p>
</li>
</ol>
<p>外部函数的活动对象也会保存一个引用</p>
</li>
</ul>
<ul>
<li><p>模仿块级作用域</p>
<p> JS没有块级作用域, <strong>匿名函数模仿块级作用域(私有作用域)</strong></p>
</li>
</ul>
<p>经常在全局作用域中被用在函数外部。</p>
<p>创建私有作用域，限制了向全局作用域中添加过多的变量和函数。</p>
<p>较少闭包占用内存，没有指向匿名函数的引用，函数执行完毕立即销毁作用域链。</p>
<ul>
<li><p>私有变量</p>
<p>js 没有私有成员概念，有私有变量概念。私有变量包含：函数的参数、局部变量和在函数内部定义的其他函数</p>
<p>有权访问私有变量和私有函数的公有方法称为特权方法。</p>
<p>访问私有变量的公有方法，创建闭包</p>
<ul>
<li>构造函数定义特权方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">obj</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">//私有变量和私有函数</span></span><br><span class="line">	<span class="keyword">var</span> variable = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//特权方法</span></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">public</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		variable++;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">fun</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//除了使用public()这个途径没有其他方法可以直接访问variable和fun().</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">		name = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>私有变量name在每个Dog实例中都不相同，</p>
<p>每次调用构造函数都会重新创建这两个方法。</p>
</li>
</ul>
<p>  缺点：必须使用构造函数模式，会针对每个实例都创建同样一组方法。</p>
<p>  解决方法：静态私有变量</p>
<ul>
<li><p>静态私有变量</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">	//私有变量和私有函数</span><br><span class="line">	var variable = 10;</span><br><span class="line">	function fun()&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">	//构造函数 全局变量 非严格模式</span><br><span class="line">	obj = function()&#123;&#125;;</span><br><span class="line">	//公有/特权方法</span><br><span class="line">	obj.prototype.public = function()&#123;</span><br><span class="line">		variable++;</span><br><span class="line">		return fun();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<ol>
<li><p>创建了一个私有作用域</p>
</li>
<li><p>公有方法在原型上定义</p>
</li>
<li><p>构造函数使用函数表达式</p>
</li>
<li><p>构造函数申明没有用var(初始化未经声明的变量，会创建一个全局变量 非严格模式)</p>
</li>
<li><p>私有变量和函数是由所有实例共享的</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="title class_">Dog</span> = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">		name = val;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">		name = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;M&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;N&quot;</span>)</span><br><span class="line"><span class="title function_">alert</span>(p1.<span class="title function_">getName</span>()) <span class="comment">// &quot;N&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(p2.<span class="title function_">getName</span>()) <span class="comment">// &quot;N&quot;</span></span><br></pre></td></tr></table></figure>

<p>一个实例上调用setName会影响所有实例。</p>
<ul>
<li>变量name变为一个静态的、由所有实例共享的属性</li>
<li>这种方式可以通过原型实现代码复用，但是每个实例都没有自己的私有变量</li>
<li>多查找作用域链中的一个层次，就会在一定程度上影响查找速度，这也是使用闭包和私有变量的一个明显的不足之处</li>
</ul>
</li>
<li><p>模块模式<br>为单例创建私有变量和特权方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和函数</span></span><br><span class="line">	<span class="keyword">var</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BashComponent</span>());</span><br><span class="line">  <span class="comment">// 公共</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getComponentCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="attr">registerComponent</span>:<span class="keyword">function</span>(<span class="params">conponent</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">        components.<span class="title function_">push</span>(component);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>一般应用于只需要创建单个对象，并以某些数据进行初始化，还要公开一些方法进行私有数据访问的情况。单例通常都是作为全局对象存在的。</p>
</li>
</ul>
<ul>
<li><p>增强模块模式</p>
<p>加入对其增强的代码，适合那些单例必须是某种类型的实例，同时还必须添加某些属性和方法对其加以增强的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> application = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 私有变量和函数</span></span><br><span class="line">	<span class="keyword">var</span> components = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  components.<span class="title function_">push</span>(<span class="keyword">new</span> <span class="title class_">BashComponent</span>());</span><br><span class="line">  <span class="comment">// 创建某种类型的实例</span></span><br><span class="line">  <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">BaseComponent</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公共</span></span><br><span class="line">  app.<span class="property">getComponentCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> components.<span class="property">length</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  app.<span class="property">registerComponent</span> : <span class="keyword">function</span>(<span class="params">conponent</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">typeof</span> component == <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">       components.<span class="title function_">push</span>(component);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h1 id="八-BOM"><a href="#八-BOM" class="headerlink" title="八. BOM"></a>八. BOM</h1><h2 id="window-对象——BOM的核心对象"><a href="#window-对象——BOM的核心对象" class="headerlink" title="window 对象——BOM的核心对象"></a>window 对象——BOM的核心对象</h2><p>window对象有双重角色，通过JS访问浏览器窗口的一个接口，又是ECMAScript规定的Clobal对象。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>全局变量会成为<code>window</code>对象的属性</p>
<p>定义全局变量与在<code>window</code>对象上直接定义属性还是有一点差别：<strong>全局变量不能通过<code>delete</code>操作符删除，而直接定义在<code>window</code>对象上的定义的属性可以</strong>。</p>
<h3 id="窗口和框架的关系"><a href="#窗口和框架的关系" class="headerlink" title="窗口和框架的关系"></a>窗口和框架的关系</h3><p>框架frames 通过数值索引，从0开始，从左至右，从上到下</p>
<p>在没有框加情况下，parent == top == window</p>
<h3 id="窗口位置"><a href="#窗口位置" class="headerlink" title="窗口位置"></a>窗口位置</h3><p>IE9+、Firefox、Safari、Opera和Chrome均提供了4个属性<code>innerWidth</code>、<code>innerHeight</code>、<code>outerWidth</code>和<code>outerHeight</code>。</p>
<ul>
<li>IE9+、Safari和Firefox中，<code>outerWidth</code>和<code>outerHeight</code>返回浏览器窗口本身的尺寸，而<code>innerWidth</code>和<code>innerHeight</code>则表示该容器中页面视图区的大小（减去边框宽度）</li>
<li>Chrome中，<code>inner*</code>和<code>outer*</code>返回相同的值，即视口大小而非浏览器窗口的大小。</li>
<li>在IE、Firefox、Safari、Opera和Chrome中，都能通过<code>document.documentElement.clientWidth</code>和<code>document.documentElement.clientHeight</code>中保存了页面视口信息。</li>
</ul>
<p>获取页面视口大小</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>,</span><br><span class="line">    pageHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> pageWidth != <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&#x27;CSS1Compat&#x27;</span>) &#123; <span class="comment">// 浏览器标准模式</span></span><br><span class="line">        pageWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line">        pageHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// IE6 混杂模式</span></span><br><span class="line">        pageWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span><br><span class="line">        pageHeight = <span class="variable language_">document</span>.<span class="property">doby</span>.<span class="property">clientHeight</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>resizeTo()</code>接受浏览器窗口的新宽度和新高度</li>
<li><code>resizeBy()</code>接受新窗口与原窗口的宽度和高度差。</li>
</ul>
<p>这两个方法可能被浏览器禁用。</p>
<h3 id="导航位置"><a href="#导航位置" class="headerlink" title="导航位置"></a>导航位置</h3><p>如果是浏览器内置的<strong>屏蔽</strong>程序组织的弹出窗口，那么<code>window.open()</code>很可能会<strong>返回<code>null</code></strong></p>
<p>window.open(url, 窗口目标(iframe name | _self | _parent | _top | _blank)，windowFeatures字符串，是否取代浏览器历史)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;https://baidu.com&quot;</span>, <span class="string">&quot;topframe&quot;</span>)</span><br><span class="line">myWindow=<span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;https://baidu.com&quot;</span>, <span class="string">&quot;topframe&quot;</span>,<span class="string">&#x27;width=200,height=100&#x27;</span>);<span class="comment">// 这里的topframe是不存在的窗口或框架，会打开一个新的</span></span><br><span class="line">myWindow.<span class="title function_">close</span>()</span><br><span class="line">myWindow.<span class="title function_">resizeTo</span>()</span><br><span class="line">myWindow.<span class="title function_">moveTo</span>()</span><br></pre></td></tr></table></figure>

<h3 id="间歇和超时调用"><a href="#间歇和超时调用" class="headerlink" title="间歇和超时调用"></a>间歇和超时调用</h3><p><strong>setTimeout()</strong></p>
<p><strong>setInterval()</strong></p>
<p><strong>clearTimeout()</strong></p>
<p><strong>clearInterval()</strong></p>
<h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p>alert()</p>
<p>confirm() // 返回 true ok、false cancel </p>
<p>prompt() // 返回文本输入域的值</p>
<p>window.print() // 打印</p>
<p>window.find() // 查找</p>
<h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>即是window 对象属性 也是document 对象属性</p>
<p>window.location = document.location</p>
<p><code>location</code>对象的属性 保存URL解析内容</p>
<ul>
<li><p><code>hash</code></p>
</li>
<li><p><code>host</code></p>
</li>
<li><p><code>hostname</code>：与<code>host</code>不同的是，不带端口号</p>
</li>
<li><p><code>href</code></p>
</li>
<li><p><code>pathname</code>: 返回URL中的目录和（或）文件名</p>
</li>
<li><p><code>port</code></p>
</li>
<li><p><code>protocol</code></p>
</li>
<li><p><strong><code>search</code></strong>：返回URL的查询字符串，这个字符串<code>?</code>开头</p>
<p>location.assign (URL)  等价 window.location = URL // 浏览器历史记录会创建新纪录</p>
<p>location.replace() // 不产生记录</p>
<p>location.reload()  // 重新加载</p>
</li>
</ul>
<h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p><code>navigator</code>对象的属性 识别客户端浏览器</p>
<ul>
<li><code>appCodeName</code>: 浏览器的名称，通常都是Mozilla</li>
<li><code>appMinorVersion</code>：此版本信息</li>
<li><code>appName</code>: 完整的浏览器名称</li>
<li><code>appVersion</code>：浏览器的版本</li>
<li><code>buildID</code>：浏览器编译版本</li>
<li><code>cookieEnabled</code>：表示<code>cookie</code>是否可用</li>
<li><code>cpuClass</code>：客户端计算机中使用的CPU类型</li>
<li><code>javaEnabled()</code>：表示当前浏览器中是否启用了java</li>
<li><code>language</code>: 浏览器的主语言</li>
<li><code>mimeTypes</code>：浏览器中注册的MIME类型数组</li>
<li><code>onLine</code>：表示浏览器是都连接到因特网</li>
<li><code>oscpu</code>：客户端计算机的操作系统或使用的CPU</li>
<li><code>platform</code>：浏览器所在的系统平台</li>
<li><code>**plugins**</code>：浏览器中安装的插件信息的数组</li>
<li><code>preference()</code>：设置用户的首选项</li>
<li><code>systemLanguage</code>：操作系统的语言</li>
<li><code>userAgent</code>：浏览器的用户代理字符串</li>
</ul>
<h2 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h2><p>表明客户端的能力</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>保存用户历史记录</p>
<p>history.go(-1) // 后退</p>
<p>history.go(1) // 前进</p>
<p>history.back() // 后退</p>
<p>history.forward() // 前进</p>
<p>history.length // 返回记录数量</p>
<h1 id="十-DOM"><a href="#十-DOM" class="headerlink" title="十.  DOM"></a>十.  DOM</h1><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><h3 id="node类型"><a href="#node类型" class="headerlink" title="node类型"></a>node类型</h3><p>每个节点都有一个<code>nodeType</code>属性，用于表明节点的类型。</p>
<ul>
<li><code>Node.ELEMENT_NODE(1)</code></li>
<li><code>Node.ATTRIBUTE_NODE(2)</code></li>
<li><code>Node.TEXT_NODE(3)</code></li>
<li><code>Node.CDATA_SECTION_NODE(4)</code></li>
<li><code>Node.ENTITY_REFERENCE_NODE(5)</code></li>
<li><code>Node.ENTITY_NODE(6)</code></li>
<li><code>Node.PROCESSING_INSTRUCTION_NODE(7)</code></li>
<li><code>Node.COMMENT_NODE(8)</code></li>
<li><code>Node.DOCUMENT_NODE(9)</code></li>
<li><code>Node.DOCUMENT_TYPE_NODE(10)</code></li>
<li><code>Node.DOCUMENT_FRAGMENT_NODE(11)</code></li>
<li><code>Node.NOTATION_NODE(12)</code></li>
</ul>
<p>为了确保跨浏览器兼容，将<code>nodeType</code>属性与数字值进行比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Node is an element&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>nodeName</code>属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.<span class="property">nodeType</span> == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = someNode.<span class="property">nodeName</span>;  <span class="comment">// nodeName的值是元素的标签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h5><ul>
<li><code>childNodes</code>属性</li>
</ul>
<p>每个节点都有一个<code>childNodes</code>属性，其中保存着一个<code>NodeList</code>对象，该对象是一种类数组对象。</p>
<ul>
<li><code>parentNode</code>属性</li>
</ul>
<p>每个节点都有一个<code>parentNode</code>属性，该属性指向文档树中的父节点。包含在<code>childNodes</code>列表中的每个节点相互都是兄弟节点。</p>
<ul>
<li>使用<code>previousSibling</code>和<code>nextSibling</code>属性，可以访问其他兄弟节点。</li>
</ul>
<p><strong>注</strong>：列表中第一个节点的<code>previousSibling</code>属性值为<code>null</code>，同理列表中最后一个节点的<code>nextSibling</code>属性也是<code>null</code>。父节点的<code>firstChild</code>和<code>lastChild</code>属性分别指向其<code>childNodes</code>列表中的第一个和最后一个节点。如果不存在则为<code>null</code>。</p>
<ul>
<li><p><code>hasChildNodes()</code>方法在节点包含一个或多个子节点的情况下返回<code>true</code>，比查询<code>childNodes.length</code>更简便。</p>
</li>
<li><p>所有节点的最后一个属性<strong><code>ownerDocument</code></strong>，该属性指向表示整个文档的文档节点（root），直接返回根节点不需要一层层向上回溯。</p>
</li>
</ul>
<h5 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h5><ul>
<li><code>appendChild()</code></li>
</ul>
<p>用于向<code>childNodes</code>列表的末尾添加一个节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> returnedNode = someNode.<span class="title function_">appendChild</span>(newNode);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(someNode.<span class="property">lastChild</span> == newNode); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>任何DOM节点不可能同时出现在多个位置。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//someNode 有多个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.<span class="title function_">appendChild</span>(someNode.<span class="property">firstChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">firstChild</span>); <span class="comment">//false</span></span><br><span class="line"><span class="title function_">alert</span>(returnedNode == someNode.<span class="property">lastChild</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>insertBefore()</code></li>
</ul>
<p>把节点放在指定位置，该方法接受两个参数：要插入的节点和作为参考的节点。插入节点后，被插入的节点会变成参照节点的前一个兄弟节点。参照节点是<code>null</code>的话，<code>insertBefore</code>与<code>appendChild</code>执行相同的操作，都插入列表末尾。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入后成为最后一个子节点</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, <span class="literal">null</span>);</span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">lastChild</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入后成为第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">firstChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(returnedNode == newNode); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">firstChild</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到最后一个子节点前面</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">insertBefore</span>(newNode, someNode.<span class="property">lastChild</span>);</span><br><span class="line"><span class="title function_">alert</span>(newNode == someNode.<span class="property">childNodes</span>[someNode.<span class="property">childNodes</span>.<span class="property">length</span>-<span class="number">2</span>]); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>replaceChild()</code></li>
</ul>
<p>替换节点，接受两个参数：要插入的节点和要替换的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//替换第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> returnedNode = someNode.<span class="title function_">replaceChild</span>(newNode, someNode.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换最后一个子节点</span></span><br><span class="line">returnedNode = someNode.<span class="title function_">replaceChild</span>(newNode, someNode.<span class="property">lastChild</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>removeChild()</code></li>
</ul>
<p>移除节点，接受一个参数：要被移除的节点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除第一个子节点</span></span><br><span class="line"><span class="keyword">var</span> formerFirstChild = someNode.<span class="title function_">removeChild</span>(someNode.<span class="property">firstChild</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除最后一个子节点</span></span><br><span class="line"><span class="keyword">var</span> formerLastChild = someNode.<span class="title function_">removeChild</span>(someNode.<span class="property">lastChild</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>cloneNode()</code></li>
</ul>
<p>复制节点，接受一个布尔值，表示是否深复制。复制后返回的节点没有父节点，可以通过插入等操作手动指定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deepList = myList.<span class="title function_">cloneNode</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="title function_">alert</span>(deepList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">//3（IE &lt; 9）或7（其他浏览器）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shallowList = myList.<span class="title function_">cloneNode</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="title function_">alert</span>(shallowList.<span class="property">childNodes</span>.<span class="property">length</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：<code>cloneNode</code>方法不会复制DOM节点的<code>js</code>属性。IE存在一个bug，它会复制事件处理程序。</p>
<ul>
<li><code>normalize()</code></li>
</ul>
<h4 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h4><p><code>Document</code>节点具有下列特征：</p>
<ul>
<li><code>nodeType</code>的值为9</li>
<li><code>nodeName</code>的值为<code>#document</code></li>
<li><code>nodeValue</code>的值为<code>null</code></li>
<li><code>parentNode</code>的值为<code>null</code></li>
<li><code>ownerDocument</code>的值为<code>null</code></li>
<li>其子节点可能是一个<code>DocumentType</code>（最多一个）、<code>Element</code>（最多一个）、<code>ProcessingInstruction</code>或<code>Comment</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过`documentElement`属性访问&lt;html&gt;元素</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line"><span class="comment">// 访问 &lt;body&gt; 元素</span></span><br><span class="line"><span class="keyword">var</span> body = <span class="variable language_">document</span>.<span class="property">body</span>;</span><br><span class="line"><span class="comment">// &lt;!DOCTYPE&gt;</span></span><br><span class="line"><span class="keyword">var</span> doctype = <span class="variable language_">document</span>.<span class="property">doctype</span>;</span><br><span class="line"><span class="comment">// &lt;title&gt;</span></span><br><span class="line"><span class="keyword">var</span> title = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"><span class="comment">// 完整 url</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="variable language_">document</span>.<span class="property">URL</span>;</span><br><span class="line"><span class="comment">// domain 域名</span></span><br><span class="line"><span class="keyword">var</span> domain = <span class="variable language_">document</span>.<span class="property">domain</span>;</span><br><span class="line"><span class="comment">// 取得来源页面的URL(也就是导航到这页的页面)</span></span><br><span class="line"><span class="keyword">var</span> referrer = <span class="variable language_">document</span>.<span class="property">referrer</span>;</span><br></pre></td></tr></table></figure>

<p>查找元素的方法：</p>
<ul>
<li><p><code>document.getElementById()</code></p>
</li>
<li><p><code>document.getElementsByTagName()</code></p>
</li>
<li><p><code>document.getElementsByName()</code> // 参数* 全部</p>
</li>
<li><p>文档写入：</p>
</li>
<li><p><code>document.write()</code></p>
</li>
<li><p><code>document.writeln()</code>在字符串尾加换行符(\n)</p>
</li>
<li><p>如下动态包含外部资源，方法open() close（）打开关闭网页输出流</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;&lt;script type=\&quot;text/javascript\&quot; src=\&quot;file.js\&quot;&gt;&quot;</span> + <span class="string">&quot;&lt;\/script&gt;&quot;</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h4><p><code>Element</code>类型提供了对元素标签名、子节点及特性的访问。</p>
<ul>
<li><code>nodeType</code>的值为1</li>
<li><code>nodeName</code>的值为元素的标签名</li>
<li><code>nodeValue</code>的值为<code>null</code></li>
<li><code>parentNode</code>可能是<code>Document</code>或<code>Element</code></li>
<li>其子节点可能是<code>Element</code>、<code>Text</code>、<code>Comment</code>、<code>ProcessingInstruction</code>、<code>CDATASection</code>或<code>EntityReference</code></li>
</ul>
<p>访问元素的标签名，可以使用<code>nodeName</code>属性，也可以使用<code>tagName</code>属性，后者更直观。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span>); <span class="comment">//&quot;DIV&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(div.<span class="property">tagName</span> == div.<span class="property">nodeName</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>操作特性的方法：</p>
<ul>
<li><code>getAttribute()</code></li>
<li><code>setAttribute()</code></li>
<li><code>removeAttribute()</code></li>
</ul>
<p><code>attributes</code>属性</p>
<p><code>Element</code>类型是使用<code>attributes</code>属性的唯一一个DOM节点属性。<code>attributes</code>属性包含一个<code>NamedNodeMap</code>。元素的每一个特性都由一个<code>Attr</code>节点表示，每个节点都保存在<code>NamedNodeMap</code>对象中。</p>
<p><code>NamedNodeMap</code>对象的方法：</p>
<ul>
<li><code>getNamedItem(name)</code>：返回<code>nodeName</code>属性等于<code>name</code>的节点</li>
<li><code>removeNamedItem(name)</code>：从列表中移除<code>nodeName</code>属性等于<code>name</code>的节点</li>
<li><code>setNamedItem(node)</code>：向列表中添加节点，以节点的<code>nodeName</code>属性为索引</li>
<li><code>item(pos)</code>：返回位于数字<code>pos</code>位置处的节点</li>
</ul>
<p><code>attributes</code>属性中包含一系列节点，每个节点的<code>nodeName</code>就是特性的名称，而节点<code>nodeValue</code>就是特性的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = element.<span class="property">attributes</span>.<span class="title function_">getNamedItem</span>(<span class="string">&#x27;id&#x27;</span>).<span class="property">nodeValue</span>;</span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="keyword">var</span> id = element.<span class="property">attributes</span>[<span class="string">&#x27;id&#x27;</span>].<span class="property">nodeValue</span>;</span><br></pre></td></tr></table></figure>

<p>创建元素<br> <code>document.createElement()</code>方法可以创建新元素，这个方法接受一个参数（标签名）或者完整的元素标签</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;&lt;div id=\&quot;MYDIV\&quot;&gt;&lt;/div&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h4><p>文本节点由<code>Text</code>类型表示，包含的是可以照字面解释的纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。</p>
<ul>
<li><code>nodeType</code>的值为3</li>
<li><code>nodeName</code>的值为<code>#text</code></li>
<li><code>nodeValue</code>的值为节点所包含的文本</li>
<li><code>parentNode</code>是一个<code>Element</code></li>
<li>不支持（没有）子节点</li>
</ul>
<p><strong>操作节点中的文本</strong>：</p>
<ul>
<li><code>appendData(text)</code>：将<code>text</code>添加到节点的末尾</li>
<li><code>deleteData(offset, count)</code>：从<code>offset</code>指定的位置开始删除<code>count</code>个字符</li>
<li><code>insertData(offset, text)</code>：在<code>offset</code>指定的位置插入<code>text</code></li>
<li><code>replaceData(offset, count, text)</code>：用<code>text</code>替换从<code>offset</code>指定的位置开始到<code>offset+count</code>为止的文本</li>
<li><code>splitText(offset)</code>：从<code>offset</code>指定的位置将当前文本分成两个文本节点</li>
<li><code>substringData(offset, count)</code>：提取从<code>offset</code>指定的位置开始到<code>offset+count</code>为止处的字符串。</li>
<li>length 属性，nodevalue.length= data.length</li>
</ul>
<p>在向DOM文档中插入文本之前，应该先对其进行<code>HTML</code>编码</p>
<p><strong>创建文本节点</strong></p>
<ul>
<li><code>document.createTextNode()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h4><ul>
<li><code>nodeType</code>的值为8</li>
<li><code>nodeName</code>的值为<code>#comment</code></li>
<li><code>nodeValue</code>的值为注释的内容</li>
<li><code>parentNode</code>是一个<code>Document</code> 或<code>Element</code></li>
<li>不支持（没有）子节点</li>
</ul>
<p>创建注释节点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意在html 标签中添加</span></span><br><span class="line"><span class="keyword">var</span> comment = <span class="variable language_">document</span>.<span class="title function_">createComment</span>(<span class="string">&quot;A Comment&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h4><ul>
<li><code>nodeType</code>的值为10</li>
<li><code>nodeName</code>的值为doctype的名称</li>
<li><code>nodeValue</code>的值为null</li>
<li><code>parentNode</code>是一个<code>Document</code> </li>
<li>不支持（没有）子节点</li>
<li>不能动态创建，只能通过解析文档方式创建</li>
</ul>
<h4 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h4><ul>
<li><code>nodeType</code>的值为11</li>
<li><code>nodeName</code>的值<code>#document-fragment</code></li>
<li><code>nodeValue</code>的值为null</li>
<li><code>parentNode</code>是一个null</li>
<li>其子节点可能是<code>Element</code>、<code>ProcessingInstruction</code>、<code>Comment</code>、<code>Text</code>、<code>CDATASection</code>或<code>EntityReference</code></li>
</ul>
<h4 id="DocumentFragment类型-1"><a href="#DocumentFragment类型-1" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h4><ul>
<li><code>nodeType</code>的值为11</li>
<li><code>nodeName</code>的值<code>#document-fragment</code></li>
<li><code>nodeValue</code>的值为null</li>
<li><code>parentNode</code>是一个null</li>
<li>其子节点可能是<code>Element</code>、<code>ProcessingInstruction</code>、<code>Comment</code>、<code>Text</code>、<code>CDATASection</code>或<code>EntityReference</code></li>
</ul>
<h4 id="Attr-类型"><a href="#Attr-类型" class="headerlink" title="Attr 类型"></a>Attr 类型</h4><ul>
<li><code>nodeType</code>的值为2</li>
<li><code>nodeName</code>的值为特性的名称</li>
<li><code>nodeValue</code>的值为特性的值</li>
<li><code>parentNode</code>是一个null</li>
<li>HTML中不支持（没有）子节点 XML中可以是<code>Text</code>或<code>EntityReference</code></li>
</ul>
<h3 id="DOM-操作技术"><a href="#DOM-操作技术" class="headerlink" title="DOM 操作技术"></a>DOM 操作技术</h3><h4 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h4><p>使用函数实现加载外部<code>JS</code>文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadScript</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.<span class="property">type</span> = <span class="string">&#x27;text/javascript&#x27;</span>;</span><br><span class="line">    script.<span class="property">src</span> = url;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">loadScirpt</span>(<span class="string">&#x27;xx.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>IE将<code>&lt;script&gt;</code>视为一个特殊的元素，不允许DOM访问其子节点。不过可以使用<code>&lt;script&gt;</code>元素的<code>text</code>属性指定<code>JS</code>代码。</p>
<h4 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=<span class="string">&quot;main.css&quot;</span> rel=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addCssByLink</span>(<span class="params">url</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> doc=<span class="variable language_">document</span>;</span><br><span class="line">	<span class="keyword">var</span> link=doc.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">	link.<span class="title function_">setAttribute</span>(<span class="string">&quot;rel&quot;</span>, <span class="string">&quot;stylesheet&quot;</span>);</span><br><span class="line">    link.<span class="title function_">setAttribute</span>(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text/css&quot;</span>);</span><br><span class="line">    link.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>, url);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">var</span> heads = doc.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;head&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(heads.<span class="property">length</span>) &#123;</span><br><span class="line">		heads[<span class="number">0</span>].<span class="title function_">appendChild</span>(link);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		doc.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create table</span></span><br><span class="line"><span class="keyword">var</span> table = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;table&#x27;</span>);</span><br><span class="line">table.<span class="property">border</span> = <span class="number">1</span>;</span><br><span class="line">table.<span class="property">width</span> = <span class="string">&#x27;100%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create tbody</span></span><br><span class="line"><span class="keyword">var</span> tbody = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;tbody&#x27;</span>);</span><br><span class="line">table.<span class="title function_">appendChild</span>(tbody);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create row1</span></span><br><span class="line"><span class="keyword">var</span> row1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell1_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">cell1_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Cell 1,1&#x27;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell1_1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell2_1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">cell2_1.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Cell 2,1&#x27;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell2_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create row2</span></span><br><span class="line"><span class="keyword">var</span> row2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line">tbody.<span class="title function_">appendChild</span>(row2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell1_2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">cell1_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Cell 1,2&#x27;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell1_2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cell2_2 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;td&#x27;</span>);</span><br><span class="line">cell2_2.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Cell 2,2&#x27;</span>));</span><br><span class="line">row1.<span class="title function_">appendChild</span>(cell2_2);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(table);</span><br></pre></td></tr></table></figure>

<p>为<table>元素添加的属性和方法如下<br>口 caption: 保存着对<caption>元素( 如果有)的指针<br>口 tBodies:是一个<tbody>元素的 HTMLCollectione<br>口 tFoot:保存对<tfoot>元素( 如有)的指针<br>tHead:保存着对<thead>元素(如果有的指针。<br>rows:是一个表格中所有行的 HTMLCollection。<br>createTHead():创建<thead>元素，将其放到表格中，返回引用<br> createTPoot():创建<tfoot>元素，将其放到表格中，返回引用。<br>createCaption():创建<caption>元素，将其放到表格中，返回引用<br>口 deleteTHead():剥除<thead>元素。<br>口 deleteTFoot ): 删除<tfoot>元素。<br>口 deleteCaption(): 删除<caption>元素。<br>口 deleteRow(pos):删除指定位置的行。<br>口 insertRow(pos]:向 rows 集合中的指定位置插人一行。<br>为<tbody>元素添加的属性和方法如下。<br>口 rows:保存着<tbody>元素中行的 HTMLCollection。<br>口 deleteRow(pos): 删除指定位置的行。<br>口 insertRow(pos):向rows 集合中的指定位置插入一行，返回对新插人行的引用。<br>为<tr>元素添加的属性和方法如下。</p>
<p> cells:保存着<tr>元素中单元格的 HTMLColectiona<br>口 deleteCell(pos):删除指定位置的单元格。口insertCel1(pos):向ce11s 集合中的指定位置插人一个单元格，返对新插人单元格的引用使用这些属性和方法，可以极大地减少创建表格所需的代码数量。例如，使用这些属性和方法可以将前面的代码重写如下(加阴影的部分是重写后的代码</p>
<h1 id="十一-DOM-扩展"><a href="#十一-DOM-扩展" class="headerlink" title="十一. DOM 扩展"></a>十一. DOM 扩展</h1><h3 id="选择符-API"><a href="#选择符-API" class="headerlink" title="选择符 API"></a>选择符 API</h3><ul>
<li><code>querySelector()</code>方法</li>
</ul>
<p><code>querySelector()</code>方法接受一个<strong>CSS</strong>选择符，返回与该模式匹配的<strong>第一个元素</strong>，若没有，返回<code>null</code>。</p>
<p>可以通过<code>Document</code>类型调用，也可以通过<code>Element</code>类型调用，后者只会在该元素后代元素的范围内查找匹配的元素。</p>
<ul>
<li><code>querySelectorAll()</code>方法</li>
</ul>
<p><code>querySelectorAll()</code>方法返回的是所有匹配的元素，是一个<code>NodeList</code>实例。</p>
<ul>
<li><code>matchesSelector()</code>方法</li>
</ul>
<p>为<code>Element</code>类型新增的一个方法，接受一个参数<code>CSS</code>选择符，如果调用元素与该选择符匹配，返回<code>true</code>，否则返回<code>false</code>。</p>
<h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><ul>
<li><code>getElementsByClassName()</code>方法</li>
<li><code>classList</code>属性，这个属性是新集合类型<code>DOMTokenList</code>的实例<ul>
<li><code>add(value)</code></li>
<li><code>contains(value)</code>  返回true|false</li>
<li><code>remove(value)</code></li>
<li><code>toggle(value)</code></li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h4><p><code>document.activeElement</code>属性，始终会引用DOM中前端获得了焦点的元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.<span class="title function_">focus</span>();</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">activeElement</span> === button); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><code>document.hasFocus()</code>方法，可以确定文档是否获得了焦点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myButton&quot;</span>);</span><br><span class="line">button.<span class="title function_">focus</span>();</span><br><span class="line"><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="title function_">hasFocus</span>()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a><code>HTMLDocument</code>的变化</h4><ul>
<li><code>readyState</code>属性有两个值，<code>loading</code>和<code>complete</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">readyState</span> == <span class="string">&#x27;complete&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 加载完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>兼容模式： document.compatMode 采用什么渲染模式</li>
</ul>
<p>CSS1Compat 标准模式  BackCompat  混杂模式</p>
<h4 id="document-charset字符集属性"><a href="#document-charset字符集属性" class="headerlink" title="document.charset字符集属性"></a><code>document.charset</code>字符集属性</h4><p><code>document.charset</code>和 <code>document.defaultCharset</code>不一定相等</p>
<h4 id="data-自定义数据属性"><a href="#data-自定义数据属性" class="headerlink" title="data-自定义数据属性"></a><code>data-</code>自定义数据属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;myDiv&quot;</span> data-appId=<span class="string">&quot;12345&quot;</span> data-myname=<span class="string">&quot;Nicholas&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取得自定义属性的值</span></span><br><span class="line"><span class="keyword">var</span> appId = div.<span class="property">dataset</span>.<span class="property">appId</span>;</span><br><span class="line"><span class="keyword">var</span> myName = div.<span class="property">dataset</span>.<span class="property">myname</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">appId</span> = <span class="number">23456</span>;</span><br><span class="line">div.<span class="property">dataset</span>.<span class="property">myname</span> = <span class="string">&quot;Michael&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a><code>innerHTML</code>属性</h4><p>在读模式下，<code>innerHTML</code> 属性返回与调用元素的<strong>所有子节点</strong>（包括元素、注释和文本节点）对应<br> 的HTML 标记。在写模式下，<code>innerHTML</code> 会根据指定的值创建新的DOM树，然后用这个DOM树完全<br> 替换调用元素原先的所有子节点</p>
<h4 id="outerHTML属性"><a href="#outerHTML属性" class="headerlink" title="outerHTML属性"></a><code>outerHTML</code>属性</h4><p>在读模式下，<code>outerHTML</code> 返回<strong>调用它的元素及所有子节点</strong>的HTML 标签。在写模式下，<code>outerHTML</code><br> 会根据指定的HTML 字符串创建新的DOM 子树，然后用这个DOM子树完全替换调用元素。</p>
<h4 id="insertAdjacentHTML-方法"><a href="#insertAdjacentHTML-方法" class="headerlink" title="insertAdjacentHTML()方法"></a><code>insertAdjacentHTML()</code>方法</h4><p>插入元素的新增方法，接受两个参数，插入的位置和要插入的HTML文本，第一个参数的值：</p>
<ul>
<li><code>&#39;beforebegin&#39;</code></li>
<li><code>&#39;afterbegin&#39;</code></li>
<li><code>&#39;beforeend&#39;</code></li>
<li><code>&#39;afterend&#39;</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作为前一个同辈元素插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforebegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为第一个子元素插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterbegin&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为最后一个子元素插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//作为后一个同辈元素插入</span></span><br><span class="line">element.<span class="title function_">insertAdjacentHTML</span>(<span class="string">&quot;afterend&quot;</span>, <span class="string">&quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="scrollIntoView-方法"><a href="#scrollIntoView-方法" class="headerlink" title="scrollIntoView()方法"></a><code>scrollIntoView()</code>方法</h4><p><code>scrollIntoView</code>方法可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。如果这个方法传入<code>true</code>作为参数，或者不传参数，那么窗口滚动之后就会让调用元素的顶部与视口顶部 尽可能平齐，如果传入<code>false</code>，调用元素会尽可能全部出现在视口中，不过顶部不一定平齐。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让元素可见</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">form</span>[<span class="number">0</span>].<span class="title function_">scrollIntoView</span>();</span><br></pre></td></tr></table></figure>

<h3 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h3><h4 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h4><ul>
<li><code>innerText</code>属性 只子元素</li>
<li><code>outerText</code>属性 包含整个元素</li>
</ul>
<h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><ul>
<li><code>scrollIntoViewIfNeeded(alignCenter)</code>：只有在当前元素不可见的情况下，才滚动浏览器或窗口或容器元素最终让它可见。如果当前元素在视口中可见，这个方法什么也不做。</li>
<li><code>scrollByLines(lineCount)</code>：将元素的内容滚动指定的行高，<code>lineCount</code>值可以是正值，也可以是负值。</li>
<li><code>scrollByPages(pageCount)</code>：将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。</li>
</ul>
<p><code>scrollIntoView()</code>和<code>scrollIntoViewIfNeeded()</code>的作用对象是元素的容器，而<code>scrollByLines()</code>和<code>scrollByPages()</code>影响的则是元素自身。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将页面主体滚动5行</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">scrollByLines</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在当前元素不可见的时候，让它进入浏览器的视口</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">images</span>[<span class="number">0</span>].<span class="title function_">scrollIntoViewIfNeeded</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将页面主体往回滚动1 页</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">scrollByPages</span>(-<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h2 id="DOM2-和-DOM3"><a href="#DOM2-和-DOM3" class="headerlink" title="DOM2 和 DOM3"></a>DOM2 和 DOM3</h2><hr>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><h4 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h4><ul>
<li><code>offsetHeight</code>：元素在垂直方向上占用的空间大小。包括元素的高度，（可见的）水平滚动条的高度，上边框高度和下边框高度</li>
<li><code>offsetWidth</code>：元素在水平方向上占用的空间大小。包括元素的宽度，（可见的）垂直滚动条的宽度，左边框宽度和右边框宽度</li>
<li><code>offsetLeft</code>：元素的左外边框至包含元素的左内边框之间的像素距离。</li>
<li><code>offsetTop</code>：元素的上外边框至包含元素的上内边框之间的像素距离。</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/1315889-55e1c61abc26e0f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/708/format/webp" alt="img"></p>
<p>其中，<code>offsetLeft</code>和<code>offsetTop</code>属性与包含元素有关，包含元素的引用保存在<code>offsetParent</code>属性中。<code>offsetParent</code>属性不一定与<code>parentNode</code>的值相等。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素上偏移</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getElementLeft</span> (ele) &#123;</span><br><span class="line">    <span class="keyword">var</span> actualLeft = ele.<span class="property">offsetLeft</span>;</span><br><span class="line">    <span class="keyword">var</span> current = ele.<span class="property">offsetParent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">        actualLeft += current.<span class="property">offsetLeft</span>;</span><br><span class="line">        current = current.<span class="property">offsetParent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> actualLeft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素左偏移同理</span></span><br></pre></td></tr></table></figure>

<p>一般来说，页面中所有的元素都被包含在几个<code>&lt;div&gt;</code>元素中，而这些<code>&lt;div&gt;</code>元素的<code>offsetParent</code>又是<code>&lt;body&gt;</code>元素，所以<code>getElementLeft()</code>与<code>getElementTop()</code>会返回与<code>offsetLeft</code>和<code>offsetTop</code>相同的值。</p>
<h4 id="客户区大小"><a href="#客户区大小" class="headerlink" title="客户区大小"></a>客户区大小</h4><ul>
<li><code>clientWidth</code>：元素内容区宽度加上左右内边距宽度</li>
<li><code>clientHeight</code>: 元素内容区高度加上上下内边距高度</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/1315889-883b67c2a39f4eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/647/format/webp" alt="img"></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getViewport</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">compatMode</span> == <span class="string">&quot;BackCompat&quot;</span>)&#123;  <span class="comment">// IE7之前</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">width</span>: <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>,</span><br><span class="line">                <span class="attr">height</span>: <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">width</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>,</span><br><span class="line">                <span class="attr">height</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="滚动大小"><a href="#滚动大小" class="headerlink" title="滚动大小"></a>滚动大小</h4><p><strong>滚动大小</strong>，指的是包含滚动内容的元素的大小。有些元素（<code>&lt;html&gt;</code>），即使没有执行任何代码也能自动添加滚动条；但另外一些元素，则需要通过<strong>CSS</strong>的<code>overflow</code>属性设置才能滚动。</p>
<ul>
<li><code>scrollHeight</code>：在没有滚动条的情况下，元素内容的总高度</li>
<li><code>scrollWidth</code>：在没有滚动条的情况下，元素内容的总宽度</li>
<li><code>scrollLeft</code>：被隐藏在内容区域左侧的像素数，通过设置这个属性可以改变元素的滚动位置</li>
<li><code>scrollTop</code>：被隐藏在内容区域上方的像素数，通过设置这个属性可以改变元素的滚动位置</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/1315889-c980af10c1a8cf06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/737/format/webp" alt="img"></p>
<p><code>scrollWidth</code>和<code>scrollHeight</code>主要用于确定元素内容的实际大小。</p>
<p><code>scrollWidth</code> 和<code>scrollHeight</code> 与<code>clientWidth</code> 和<code>clientHeight</code> 之间的关系？</p>
<ul>
<li><strong>Firefox</strong>中这两组属性始终相等，但大小代表的是文档内容区域的实际尺寸，非视口尺寸</li>
<li><strong>Opera Safari Chrome</strong>中这两组属性有区别，其中<code>scrollWidth</code> 和<code>scrollHeight</code> 等于视口大小，而<code>clientWidth</code> 和<code>clientHeight</code> 等于文档内容区域的大小。</li>
<li><strong>IE（在标准模式）</strong>中的这两组属性不相等，其中<code>scrollWidth</code> 和<code>scrollHeight</code> 等于文档内容区域的大小，而<code>clientWidth</code> 和<code>clientHeight</code> 等于视口大小。</li>
</ul>
<p>通过<code>scrollLeft</code> 和<code>scrollTop</code> 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。在元素尚未被滚动时，这两个属性的值都等于0。如果元素被垂直滚动了，那么<code>scrollTop</code> 的值会大于0，且表示元素上方不可见内容的像素高度。如果元素被水平滚动了，那么<code>scrollLeft</code> 的值会大于0，且表示元素左侧不可见内容的像素宽度。这两个属性都是可以设置的，因此将元素的<code>scrollLeft</code> 和<code>scrollTop</code> 设置为0，就可以重置元素的滚动位置。下面这个函数会检测元素是否位于顶部，如果不是就将其回滚到顶部。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">scrollToTop</span>(<span class="params">element</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.<span class="property">scrollTop</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        element.<span class="property">scrollTop</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="确定元素大小"><a href="#确定元素大小" class="headerlink" title="确定元素大小"></a>确定元素大小</h4><ul>
<li><p><code>getBoundingClientRect()</code>方法，返回值是一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect"><code>DOMRect</code></a> 对象，是包含整个元素的最小矩形（包括 <code>padding</code> 和 <code>border-width</code>）。该对象使用 <code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>x</code>、<code>y</code>、<code>width</code> 和 <code>height</code> 单位像素只读属性</p>
</li>
<li><p>描述整个矩形的位置和大小。除了 <code>width</code> 和 <code>height</code> 以外的属性是相对于视图窗口的左上角来计算的。</p>
<p><img src="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect/element-box-diagram.png" alt="img"></p>
</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h4><p>可以使用<code>document.createNodeIterator()</code>方法创建它的新实例，接受4个参数。</p>
<ul>
<li><code>root</code>：想要作为搜索起点的树中的节点</li>
<li><code>whatToShow</code>：表示要访问哪些节点的数字代码</li>
<li><code>filter</code>：是一个<code>NodeFilter</code>对象，或者一个表示应该接受还是拒绝某种特定节点的函数</li>
<li><code>entityReferenceExpansion</code>：布尔值，表示是否要扩展实体引用。</li>
</ul>
<p><code>whatToShow</code>这个参数的值以常量形式在<code>NodeFilter</code>类型中定义：</p>
<ul>
<li><code>NodeFilter.SHOW_ALL</code></li>
<li><code>NodeFilter.SHOW_ELEMENT</code></li>
<li><code>NodeFilter.SHOW_ATTRIBUTE</code></li>
<li><code>NodeFilter.SHOW_TEXT</code></li>
<li><code>NodeFilter.SHOW_CDATA_SECTION</code></li>
<li><code>NodeFilter.SHOW_ENTITY_REFERENCE</code></li>
<li><code>NodeFilter.SHOW_ENTITYE</code></li>
<li><code>NodeFilter.SHOW_PROCESSING_INSTRUCTION</code></li>
<li><code>NodeFilter.SHOW_COMMENT</code></li>
<li><code>NodeFilter.SHOW_DOCUMENT</code></li>
<li><code>NodeFilter.SHOW_DOCUMENT_TYPE</code></li>
<li><code>NodeFilter.SHOW_DOCUMENT_FRAGMENT</code></li>
<li><code>NodeFilter.SHOW_NOTATION</code></li>
</ul>
<h4 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h4><p>NodeIterator高级版</p>
<p>nextNode()</p>
<p>previousNode()</p>
<p>parentNode()</p>
<p>firstChild()</p>
<p>lastChild()</p>
<p>nextSibling()</p>
<p>previousSibling()</p>
<h1 id="十三-事件"><a href="#十三-事件" class="headerlink" title="十三.事件"></a>十三.事件</h1><h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>IE的事件流叫做<strong>事件冒泡</strong>，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。</p>
<p><img src="/images/image-20231011115608176.png" alt="image-20231011115608176"></p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><p>Netscape 团队提出的事件流叫做<strong>事件捕获</strong>，事件捕获的用意在于在事件到达预定目标之前捕获它。</p>
<p><img src="/images/image-20231011115619191.png" alt="image-20231011115619191"></p>
<h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>“DOM2级事件”规定的事件流包括三个阶段：<code>事件捕获阶段</code>、<code>处于目标阶段</code>和<code>事件冒泡阶段</code>。</p>
<p><img src="/images/image-20231011115633911.png" alt="image-20231011115633911"></p>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><h4 id="UI-事件"><a href="#UI-事件" class="headerlink" title="UI 事件"></a>UI 事件</h4><ul>
<li><code>load</code>事件</li>
<li><code>unload</code>事件</li>
<li><code>resize</code>事件</li>
<li><code>scroll</code>事件</li>
</ul>
<h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><ul>
<li><code>blur</code>事件：失去焦点</li>
<li><code>focus</code>事件：获得焦点</li>
</ul>
<h4 id="鼠标与滚动事件"><a href="#鼠标与滚动事件" class="headerlink" title="鼠标与滚动事件"></a>鼠标与滚动事件</h4><ul>
<li><code>click</code>事件</li>
<li><code>dbclick</code>事件</li>
<li><code>mousedown</code>事件：按下鼠标</li>
<li><code>mouseenter</code>事件：光标移入</li>
<li><code>mouseleave</code>事件：光标移出</li>
<li><code>mousemove</code>事件：鼠标在元素内部移动重复触发</li>
<li><code>mouseout</code>事件：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素</li>
<li><code>mouseover</code>事件：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发</li>
<li><code>mouseup</code>事件：释放鼠标按钮时触发</li>
</ul>
<p>页面上的所有元素都支持鼠标事件。除了<code>mouseenter</code> 和<code>mouseleave</code>，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。</p>
<p>只有在同一个元素上相继触发<code>mousedown</code> 和<code>mouseup</code> 事件，才会触发<code>click</code> 事件；如果<code>mousedown</code> 或<code>mouseup</code> 中的一个被取消，就不会触发<code>click</code> 事件。</p>
<h4 id="触摸设备"><a href="#触摸设备" class="headerlink" title="触摸设备"></a>触摸设备</h4><p>iOS和Android设备的相关事件：</p>
<ul>
<li>不支持<code>dbclick</code>事件。双击浏览器窗口会放大画面</li>
<li>轻击可单击元素会触发<code>mousemove</code>事件。。如果此操作会导致内容变化，将不再有其他事件发生；如果屏幕没有因此变化，那么会依次发生<code>mousedown</code>、<code>mouseup</code> 和<code>click</code> 事件。轻击不可单击的元素不会触发任何事件。可单击的元素是指那些单击可产生默认操作的元素（如链接），或者那些已经被指定了<code>onclick</code> 事件处理程序的元素。</li>
<li><code>mousemove</code>事件也会触发<code>mouseover</code>和<code>mouseout</code>事件</li>
<li>两个手指放在屏幕上且页面随手指移动而滚动时会触发<code>mousewheel</code>和<code>scroll</code>事件。</li>
</ul>
<h4 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h4><ul>
<li><code>contextmenu</code>事件</li>
<li><code>beforeunload</code>事件</li>
<li><code>DOMContentLoaded</code>事件</li>
<li>readystatechange事件<ul>
<li><code>uninitialized</code>未初始化</li>
<li><code>loading</code></li>
<li><code>loaded</code>对象加载数据完成</li>
<li><code>interactive</code>:可以操作对象，但还没有完全加载</li>
<li><code>complete</code> 完成 对象加载完毕</li>
</ul>
</li>
<li><code>hashchange</code>事件 hash变化</li>
<li>pageshow 和pagehide 往返缓存中变化出发</li>
</ul>
<h4 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h4><p>平板手机等</p>
<ul>
<li><code>orientationchange</code>事件：横竖屏，有三个值： -90 ，0， 90</li>
</ul>
<h4 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h4><h5 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h5><ul>
<li><code>touchstart</code></li>
<li><code>touchmove</code></li>
<li><code>touchend</code></li>
<li><code>touchcancel</code></li>
</ul>
<h5 id="Touch对象属性"><a href="#Touch对象属性" class="headerlink" title="Touch对象属性"></a>Touch对象属性</h5><p>​    clientX、clientY、identifier、pageX、pageY、screanX、screanX、screanY、target</p>
<h5 id="手势事件"><a href="#手势事件" class="headerlink" title="手势事件"></a>手势事件</h5><ul>
<li><code>gesturestart</code></li>
<li><code>gesturechange</code></li>
<li><code>gestureend</code></li>
</ul>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>利用了事件冒泡</p>
<p>例如在<code>&lt;ul&gt;</code>为添加一个<code>click</code>事件，所有<code>&lt;li&gt;</code>子元素点击事件都会冒泡到<code>&lt;ul&gt;</code>上。</p>
<h1 id="十四-表单脚本"><a href="#十四-表单脚本" class="headerlink" title="十四.表单脚本"></a>十四.表单脚本</h1><h3 id="表单基础知识"><a href="#表单基础知识" class="headerlink" title="表单基础知识"></a>表单基础知识</h3><h4 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit Form&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;reset&quot;</span> value=<span class="string">&quot;Reset Form&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h4><p>每个表单都有<code>elements</code>属性，该属性是表单中所有表单元素的集合。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;form1&quot;</span>);</span><br><span class="line"><span class="comment">//取得表单中的第一个字段</span></span><br><span class="line"><span class="keyword">var</span> field1 = form.elements[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//取得名为&quot;textbox1&quot;的字段</span></span><br><span class="line"><span class="keyword">var</span> field2 = form.elements[<span class="string">&quot;textbox1&quot;</span>];</span><br><span class="line"><span class="comment">//取得表单中包含的字段的数量</span></span><br><span class="line"><span class="keyword">var</span> fieldCount = form.elements.length;</span><br></pre></td></tr></table></figure>

<h3 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h3><h4 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h4><p>文本被选中触发： 元素.select事件</p>
<p>取选择的文本：元素.selectionstart 元素.selectionEnd</p>
<p>选择部分文本： 元素.setSSelectionRange(开始位置，结束位置)</p>
<h4 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h4><p>屏蔽特定的字符，需要检测<code>keypress</code>事件对应的字符编码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 屏蔽非数字字符</span></span><br><span class="line">EventUtil.addHandler(textbox, <span class="string">&#x27;keypress&#x27;</span>, function (<span class="keyword">event</span>) &#123;</span><br><span class="line">    <span class="keyword">event</span> = EventUtil.getEvent(<span class="keyword">event</span>);</span><br><span class="line">    <span class="keyword">var</span> target = EventUtil.getTarget(<span class="keyword">event</span>);</span><br><span class="line">    <span class="keyword">var</span> charCode = EventUtil.getCharCode(<span class="keyword">event</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!/\d/.test(String.fromCharCode(charCode))) &#123;</span><br><span class="line">        EventUtil.preventDefault(<span class="keyword">event</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="HTML5约束验证API"><a href="#HTML5约束验证API" class="headerlink" title="HTML5约束验证API"></a>HTML5约束验证API</h4><h5 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h5><p>required 必填</p>
<p>type 限制如email、url、number、range、datetime、data、month、week、year</p>
<p>限制min、 max</p>
<p>HTML5为文本字段新增了<code>pattern</code>属性。正则，不需要^$</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="built_in">type</span>=<span class="string">&quot;text&quot;</span> pattern=<span class="string">&quot;\d+&quot;</span> name=<span class="string">&quot;count&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h6 id="检测有效性"><a href="#检测有效性" class="headerlink" title="检测有效性"></a>检测有效性</h6><p>使用<code>checkValidity()</code>方法可以检测表单中的某个字段是否有效。是否有效的判断依据是一些<code>&lt;input&gt;</code>的约束条件。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.forms[<span class="number">0</span>].elements[<span class="number">0</span>].checkValidity())&#123;</span><br><span class="line">    <span class="comment">//字段有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//字段无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以检测整个表单是否有效</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.forms[<span class="number">0</span>].checkValidity())&#123;</span><br><span class="line">    <span class="comment">//表单有效，继续</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//表单无效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="禁用验证"><a href="#禁用验证" class="headerlink" title="禁用验证"></a>禁用验证</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;signup.php&quot;</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里插入表单元素--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h4><p><code>&lt;select&gt;&lt;option&gt;</code></p>
<h4 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h4><p>contenteditable属性</p>
<p>document.execCommand()</p>
<h1 id="十六-HTML5-脚本编程"><a href="#十六-HTML5-脚本编程" class="headerlink" title="十六. HTML5 脚本编程"></a>十六. HTML5 脚本编程</h1><h3 id="跨文档消息传递"><a href="#跨文档消息传递" class="headerlink" title="跨文档消息传递"></a>跨文档消息传递</h3><p><strong>跨文档消息传送</strong>（cross-document messaging）简称XDM。其核心方法是<code>postMessage()</code>方法。</p>
<p><code>postMessage()</code>方法接受两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：所有支持XDM的浏览器也支持iframe的`contentWindow`属性</span></span><br><span class="line"><span class="keyword">var</span> iframeWindow = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myframe&#x27;</span>).contentWindow;</span><br><span class="line">iframeWindow.postMessage(<span class="string">&#x27;A secret&#x27;</span>, <span class="string">&#x27;https://yeasoenzhang.github.io&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>尝试向内嵌框架中发送一条消息，并指定框架中的文档必须来源于<code>https://yeasonzhang.github.io</code>域。</p>
<p>接收到<strong>XDM</strong>消息时，会触发<code>window</code>对象的<code>message</code>事件，这个事件是以异步形式触发。<br> 传递的<code>onmessage</code>处理程序的事件对象包含三个重要信息：</p>
<ul>
<li><code>data</code>：作为<code>postMessage()</code>第一个参数传入的字符串数据</li>
<li><code>origin</code>：发送消息的文档所在的域。</li>
<li><code>source</code>：发送消息的文档的<code>window</code>对象的代理。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EventUtil.addHandler(window, <span class="string">&quot;message&quot;</span>, function(<span class="keyword">event</span>)&#123;</span><br><span class="line">    <span class="comment">//确保发送消息的域是已知的域</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">event</span>.origin == <span class="string">&quot;https://yeasonzhang.github.io&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">//处理接收到的数据</span></span><br><span class="line">        processMessage(<span class="keyword">event</span>.data);</span><br><span class="line">        <span class="comment">//可选：向来源窗口发送回执</span></span><br><span class="line">        <span class="keyword">event</span>.source.postMessage(<span class="string">&quot;Received!&quot;</span>, <span class="string">&quot;http://p2p.wrox.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>XDM 还有一些怪异之处。首先，<code>postMessage()</code>的第一个参数最早是作为“永远都是字符串”来实现的。但后来这个参数的定义改了，改成允许传入任何数据结构。可是，并非所有浏览器都实现了这一变化。为保险起见，使用<code>postMessage()</code>时，最好还是只传字符串。如果你想传入结构化的数据，最佳选择是先在要传入的数据上调用<code>JSON.stringify()</code>，通过<code>postMessage()</code>传入得到的字符串，然后再在<code>onmessage</code> 事件处理程序中调用<code>JSON.parse()</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">EventUtil</span>.<span class="title function_">addHandler</span>(</span><br><span class="line">	<span class="variable language_">window</span>,<span class="string">&quot;message&quot;</span>,</span><br><span class="line">	<span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">innerHTML</span>=<span class="string">&#x27;从event.origin=&#x27;</span>+event.<span class="property">origin</span>+<span class="string">&#x27;,那里来的消息event.data=&#x27;</span>+event.<span class="property">data</span>;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h3><h4 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h4><p>拖动某个元素时，将依次触发的事件：</p>
<ul>
<li><code>dragstart</code></li>
<li><code>drag</code></li>
<li><code>dragend</code></li>
</ul>
<p>当某个元素被拖动到一个有效的放置目标时，会依次触发下列事件：</p>
<ul>
<li><code>dragenter</code></li>
<li><code>dragover</code></li>
<li><code>dragleave</code>（离开）或<code>drag</code>（放进去了）</li>
</ul>
<h4 id="dataTransfer对象"><a href="#dataTransfer对象" class="headerlink" title="dataTransfer对象"></a>dataTransfer对象</h4><p><code>dataTransfer</code>对象，它是事件对象的一个属性，用于被拖动元素向放置目标传递<strong>字符串格式</strong>的数据。该对象有两个主要方法:</p>
<ul>
<li><code>getData()</code></li>
<li><code>setData()</code></li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置和接收文本数据</span></span><br><span class="line"><span class="keyword">event</span>.dataTransfer.setData(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> text = <span class="keyword">event</span>.dataTransfer.getData(<span class="string">&quot;text&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置和接收URL</span></span><br><span class="line"><span class="keyword">event</span>.dataTransfer.setData(<span class="string">&quot;URL&quot;</span>, <span class="string">&quot;http://www.wrox.com/&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="keyword">event</span>.dataTransfer.getData(<span class="string">&quot;URL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不过，保存在<code>dataTransfer</code>对象中的数据只能在<code>drap</code>事件处理程序中读取。如果在<code>ondrop</code> 处理程序中没有读到数据，那就是<code>dataTransfer</code> 对象已经被销毁，数据也丢失了。</p>
<h4 id="drapEffect-与-effectAllowed"><a href="#drapEffect-与-effectAllowed" class="headerlink" title="drapEffect 与 effectAllowed"></a>drapEffect 与 effectAllowed</h4><p><code>dateTransfer</code>对象有两个属性：</p>
<ul>
<li><code>dropEffect</code></li>
<li><code>effectAllowed</code></li>
</ul>
<p><code>dropEffect</code>，属性可以知道被拖动的元素能够执行那种放置行为。</p>
<ul>
<li><code>none</code>：不能放在这里</li>
<li><code>move</code>：应该把拖放的元素移动到放置目标</li>
<li><code>copy</code>：应该把拖动的元素复制到放置目标</li>
<li><code>link</code>：表示放置目标会打开拖动的元素</li>
</ul>
<p>要使用<code>dropEffect</code>属性，必须在<code>ondragenter</code>事件处理程序中针对放置目标来设置。</p>
<p><code>effectAllowed</code>属性表示允许拖动元素的哪种<code>dropEffect</code>。</p>
<ul>
<li><code>uninitialized</code>：没有给被拖动的元素放置任何放置行为</li>
<li><code>none</code>：被拖动的元素不能有任何行为</li>
<li><code>copy</code>：只允许值为<code>copy</code>的<code>dropEffect</code></li>
<li><code>link</code>：只允许值为<code>link</code>的<code>dropEffect</code></li>
<li><code>move</code>：只允许值为<code>move</code>的<code>dropEffect</code></li>
<li><code>copyLink</code>：允许值为<code>copy</code>和<code>link</code>的<code>dropEffect</code></li>
<li><code>copyMove</code>：允许值为<code>copy</code>和<code>move</code>的<code>dropEffect</code></li>
<li><code>linkMove</code>：允许值为<code>link</code>和<code>move</code>的<code>dropEffect</code></li>
<li><code>all</code>: 允许任意<code>dropEffect</code></li>
</ul>
<p>必须在<code>ondragstart</code> 事件处理程序中设置<code>effectAllowed</code> 属性。</p>
<h4 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h4><p>HTML5为所有元素规定了<code>draggable</code>属性，表示元素是否可以拖动。只有图像和链接的<code>draggable</code>默认是<code>true</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 让这个图像不可以拖动 --&gt;</span></span><br><span class="line">![](smile.gif)</span><br><span class="line"><span class="comment">&lt;!-- 让这个元素可以拖动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他成员"><a href="#其他成员" class="headerlink" title="其他成员"></a>其他成员</h4><p>HTML5规定了<code>dateTransfer</code>对象还应该包含下列方法和属性。</p>
<ul>
<li><code>addElement(element)</code></li>
<li><code>clearData(format)</code></li>
<li><code>setDragImage(element, x, y)</code></li>
<li><code>type</code></li>
</ul>
<h3 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h3><p>HTML 音频(Audio)元素<br>HTML5 元素是一个 HTML5 元素，在 HTML 4 中是非法的，但在所有浏览器中都有效。<br>The element works in all modern browsers.</p>
<p>互联网上的音频</p>
<p>直到现在，仍然不存在一项旨在网页上播放音频的标准。</p>
<p>今天，大多数音频是通过插件（比如 Flash）来播放的。然而，并非所有浏览器都拥有同样的插件。</p>
<p>HTML5 规定了在网页上嵌入音频元素的标准，即使用<audio> 元素。</p>
<p>HTML 音频/视频 方法<br>HTML5 DOM 为 和 元素提供了方法、属性和事件。<br>这些方法、属性和事件允许您使用 JavaScript 来操作 和 元素。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>addTextTrack()</td>
<td>向音频/视频添加新的文本轨道。</td>
</tr>
<tr>
<td>canPlayType()</td>
<td>检测浏览器是否能播放指定的音频/视频类型。</td>
</tr>
<tr>
<td>play()</td>
<td>开始播放音频/视频。</td>
</tr>
<tr>
<td>pause()</td>
<td>暂停当前播放的音频/视频。</td>
</tr>
</tbody></table>
<h4 id="audio元素的常用属性"><a href="#audio元素的常用属性" class="headerlink" title="audio元素的常用属性"></a>audio元素的常用属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>设置或返回是否在加载完成后随即播放音频。</td>
</tr>
<tr>
<td>controls</td>
<td>设置或返回音频/视频是否显示控件（比如播放/暂停等）。</td>
</tr>
<tr>
<td>currentTime</td>
<td>设置或返回音频中的当前播放位置（以秒计）。</td>
</tr>
<tr>
<td>duration</td>
<td>返回当前音频的长度（以秒计）</td>
</tr>
<tr>
<td>ended</td>
<td>返回音频的播放是否已结束。</td>
</tr>
<tr>
<td>loop</td>
<td>设置或返回音频/视频是否应在结束时重新播放。</td>
</tr>
<tr>
<td>paused</td>
<td>设置或返回音频/视频是否暂停。</td>
</tr>
<tr>
<td>preload</td>
<td>设置或返回音频/视频是否应该在页面加载后进行加载。</td>
</tr>
</tbody></table>
<p>以下我们将使用 <audio> 标签来描述 MP3 文件(Internet Explorer、Chrome 以及 Safari 中是有效的),<br>同样添加了一个 OGG 类型文件(Firefox 和 Opera浏览器中有效)。<br>如果失败，它会显示一个错误文本信息:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">  Your browser does not support this audio format.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML5 视频(Video)元素<br>video元素的常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>autoplay</td>
<td>设置或返回是否在加载完成后随即播放音频。</td>
</tr>
<tr>
<td>controls</td>
<td>设置或返回音频/视频是否显示控件（比如播放/暂停等）。</td>
</tr>
<tr>
<td>loop</td>
<td>如果出现改属性，那么在媒体文件在完成播放后再次开始播放</td>
</tr>
<tr>
<td>width</td>
<td>设置视频播放器的宽度。</td>
</tr>
<tr>
<td>preload</td>
<td>设置或返回音频/视频是否应该在页面加载后进行加载。</td>
</tr>
</tbody></table>
<p>以下实例中使用了 4 种不同的视频格式。<br>HTML 5 <video> 元素会尝试播放以 mp4、ogg 或 webm 格式中的一种来播放视频。<br>如果均失败，则回退到 <embed> 元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.webm&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;movie.swf&quot;</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>历史状态</p>
<p>history.pushState(). history.replaceState()</p>
<h2 id="十七-错误处理与调试"><a href="#十七-错误处理与调试" class="headerlink" title="十七. 错误处理与调试"></a>十七. 错误处理与调试</h2><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h4 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出错的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 处理发生的错误</span></span><br><span class="line">&#125; finnally &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="finally子句"><a href="#finally子句" class="headerlink" title="finally子句"></a><code>finally</code>子句</h5><p>只要代码中包含<code>finially</code>子句，无论<code>try</code>还是<code>catch</code>语句中的<code>return</code>语句都将被忽略。</p>
<h5 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h5><ul>
<li><code>Error</code> 基类型</li>
<li><code>EvalError</code> eval()函数异常</li>
<li><code>RangeError</code> 超出范围</li>
<li><code>ReferenceError</code>找不到对象</li>
<li><code>SyntaxError</code></li>
<li><code>TypeError</code>意外类型</li>
<li><code>URIError</code>URI格式不正确</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">someFunction</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">TypeError</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h4><p>与<code>try-catch</code> 语句相配的还有一个<code>throw</code> 操作符，用于随时抛出自定义错误。抛出错误时，必须要给<code>throw</code> 操作符指定一个值，这个值是什么类型，没有要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; name: <span class="string">&quot;JavaScript&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">URIError</span>()</span><br></pre></td></tr></table></figure>

<p>遇到<code>throw</code>操作符时，代码会立即停止执行。只有当<code>try-catch</code>语句捕获到被抛出值，代码才会继续执行</p>
<h5 id="自定义错误类型"><a href="#自定义错误类型" class="headerlink" title="自定义错误类型"></a>自定义错误类型</h5><p>可以利用原型链通过继承<code>Error</code>创建自定义错误类型。需要为新创建的错误类型指定<code>name</code>和<code>message</code>属性</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomError</span> (message) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;CustomError&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CustomError</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">&#x27;Error msg&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Error事件"><a href="#Error事件" class="headerlink" title="Error事件"></a>Error事件</h4><p>任何没有通过<code>try-catch</code>处理的错误都会触发<code>window</code>对象的<code>error</code>事件。</p>
<p>在任何Web浏览器中，<code>onerror</code>事件处理程序都不会创建<code>event</code>对象，接受三个参数：<strong>错误消息、错误所在的URL和行号</strong>。</p>
<p>要指定onerror 事件处理程序，必须使用如下所示的DOM0 级技术，它没有遵循“DOM2 级事件”的标准格式（<code>addEventListener</code>）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, url, line</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只要发生错误，无论是不是浏览器生成的，都会触发<code>error</code>事件，然后让浏览器的默认机制发挥作用，这时候我们需要阻止浏览器的默认行为（<code>return false</code>）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">message, url, line</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">    retrun <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="常见的错误类型"><a href="#常见的错误类型" class="headerlink" title="常见的错误类型"></a>常见的错误类型</h4><ul>
<li>类型转换错误</li>
<li>数据类型错误</li>
<li>通信错误</li>
</ul>
<p>在数据检测的时候，基本类型的值应该使用<code>typeof</code>来检测，对象的值应该使用<code>instanceof</code>。</p>
<p>与服务器数据通讯：使用encodeURIComponent()进行编码。</p>
<h4 id="区分致命错误和非致命错误"><a href="#区分致命错误和非致命错误" class="headerlink" title="区分致命错误和非致命错误"></a>区分致命错误和非致命错误</h4><h4 id="把错误记录到服务器"><a href="#把错误记录到服务器" class="headerlink" title="把错误记录到服务器"></a>把错误记录到服务器</h4><h3 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h3><ol>
<li>控制台 console.log/error/info/log/warn</li>
<li>显示到用户界面</li>
<li>抛出错误 throw new error（） </li>
</ol>
<h1 id="十八-JavaScript与XML"><a href="#十八-JavaScript与XML" class="headerlink" title="十八.  JavaScript与XML"></a>十八.  JavaScript与XML</h1><p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/dandan666dandan/article/details/98391671?spm=1001.2014.3001.5502">https://blog.csdn.net/dandan666dandan/article/details/98391671?spm=1001.2014.3001.5502</a></p>
<h1 id="十九-E4X"><a href="#十九-E4X" class="headerlink" title="十九. E4X"></a>十九. E4X</h1><p>​    <a target="_blank" rel="noopener" href="https://blog.csdn.net/dandan666dandan/article/details/98467150?spm=1001.2014.3001.5502">https://blog.csdn.net/dandan666dandan/article/details/98467150?spm=1001.2014.3001.5502</a></p>
<h1 id="二十-canvas"><a href="#二十-canvas" class="headerlink" title="二十. canvas"></a>二十. canvas</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dandan666dandan/article/details/97919940?spm=1001.2014.3001.5502">https://blog.csdn.net/dandan666dandan/article/details/97919940?spm=1001.2014.3001.5502</a></p>
<p>参考</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020074034">https://segmentfault.com/a/1190000020074034</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903591983972360#heading-0">https://juejin.cn/post/6844903591983972360#heading-0</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dax1_/article/details/119717787">https://blog.csdn.net/Dax1_/article/details/119717787</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41342018/article/details/103340671">https://blog.csdn.net/weixin_41342018/article/details/103340671</a></p>
</li>
<li></li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Dax1_/article/details/119717787">v4</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ms-yip.github.io">ms.y</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ms-yip.github.io/2022/12/04/js/">https://ms-yip.github.io/2022/12/04/js/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ms-yip.github.io" target="_blank">珊珊的小本子</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/27/vue%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">vue源码系列</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/27/tsconfig-json/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">tsconfig.json</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ms.y</div><div class="author-info__description">珊珊的愿望就是有吃不完的小鱼干，还有吃不完的猪肉干牛肉干。所以在没有那么多吃的之前在这里都记着，挣到钱钱后换成喜欢的小鱼干哈</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">113</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ms-yip"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E4%BD%BF%E7%94%A8js"><span class="toc-number">1.</span> <span class="toc-text">HTML 使用js</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">四. 变量 作用域 内存问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">五. 引用类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number"></span> <span class="toc-text">六. 面向对象的程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">结合使用构造函数和原型模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%A6%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">稳妥构造函数模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88constructor-stealing%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">借用构造函数（constructor stealing）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 借用构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%EF%BC%88combination-inheritance%EF%BC%89%EF%BC%88%E5%B8%B8%E7%94%A8%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">组合继承（combination inheritance）（常用继承模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF%EF%BC%88parasitic%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">寄生式继承（parasitic）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.</span> <span class="toc-text">寄生组合式继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">七.函数表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">0.1.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">0.2.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB-BOM"><span class="toc-number"></span> <span class="toc-text">八. BOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#window-%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94BOM%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">window 对象——BOM的核心对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.</span> <span class="toc-text">全局作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%92%8C%E6%A1%86%E6%9E%B6%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">窗口和框架的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">窗口位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.</span> <span class="toc-text">导航位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%AD%87%E5%92%8C%E8%B6%85%E6%97%B6%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">间歇和超时调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">1.6.</span> <span class="toc-text">系统对话框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#location-%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">location 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#navigator-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">navigator 对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#screen%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">screen对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">history对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81-DOM"><span class="toc-number"></span> <span class="toc-text">十.  DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%B1%82%E6%AC%A1"><span class="toc-number">1.</span> <span class="toc-text">节点层次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">node类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">节点关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">操作节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Document%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">Document类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Element%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">Element类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Text%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">Text类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comment%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">Comment类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DocumentType%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">DocumentType类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DocumentFragment%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.6.</span> <span class="toc-text">DocumentFragment类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DocumentFragment%E7%B1%BB%E5%9E%8B-1"><span class="toc-number">1.1.7.</span> <span class="toc-text">DocumentFragment类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Attr-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.8.</span> <span class="toc-text">Attr 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%93%8D%E4%BD%9C%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.</span> <span class="toc-text">DOM 操作技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%84%9A%E6%9C%AC"><span class="toc-number">1.2.1.</span> <span class="toc-text">动态脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A0%B7%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">动态样式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%A1%A8%E6%A0%BC"><span class="toc-number">1.2.3.</span> <span class="toc-text">操作表格</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-DOM-%E6%89%A9%E5%B1%95"><span class="toc-number"></span> <span class="toc-text">十一. DOM 扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%AC%A6-API"><span class="toc-number">0.1.</span> <span class="toc-text">选择符 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5"><span class="toc-number">0.2.</span> <span class="toc-text">HTML5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%84%A6%E7%82%B9%E7%AE%A1%E7%90%86"><span class="toc-number">0.2.1.</span> <span class="toc-text">焦点管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLDocument%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">0.2.2.</span> <span class="toc-text">HTMLDocument的变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-charset%E5%AD%97%E7%AC%A6%E9%9B%86%E5%B1%9E%E6%80%A7"><span class="toc-number">0.2.3.</span> <span class="toc-text">document.charset字符集属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">0.2.4.</span> <span class="toc-text">data-自定义数据属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#innerHTML%E5%B1%9E%E6%80%A7"><span class="toc-number">0.2.5.</span> <span class="toc-text">innerHTML属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#outerHTML%E5%B1%9E%E6%80%A7"><span class="toc-number">0.2.6.</span> <span class="toc-text">outerHTML属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insertAdjacentHTML-%E6%96%B9%E6%B3%95"><span class="toc-number">0.2.7.</span> <span class="toc-text">insertAdjacentHTML()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scrollIntoView-%E6%96%B9%E6%B3%95"><span class="toc-number">0.2.8.</span> <span class="toc-text">scrollIntoView()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%93%E6%9C%89%E6%89%A9%E5%B1%95"><span class="toc-number">0.3.</span> <span class="toc-text">专有扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%96%87%E6%9C%AC"><span class="toc-number">0.3.1.</span> <span class="toc-text">插入文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8"><span class="toc-number">0.3.2.</span> <span class="toc-text">滚动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM2-%E5%92%8C-DOM3"><span class="toc-number">1.</span> <span class="toc-text">DOM2 和 DOM3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.</span> <span class="toc-text">元素大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">偏移量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E5%8C%BA%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">客户区大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">滚动大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">确定元素大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NodeIterator"><span class="toc-number">1.3.1.</span> <span class="toc-text">NodeIterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeWalker"><span class="toc-number">1.3.2.</span> <span class="toc-text">TreeWalker</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E4%BA%8B%E4%BB%B6"><span class="toc-number"></span> <span class="toc-text">十三.事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">0.1.</span> <span class="toc-text">事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1"><span class="toc-number">0.1.1.</span> <span class="toc-text">事件冒泡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7"><span class="toc-number">0.1.2.</span> <span class="toc-text">事件捕获</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">0.1.3.</span> <span class="toc-text">DOM事件流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">0.2.</span> <span class="toc-text">事件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UI-%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.1.</span> <span class="toc-text">UI 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%84%A6%E7%82%B9%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.2.</span> <span class="toc-text">焦点事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%B8%8E%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.3.</span> <span class="toc-text">鼠标与滚动事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E8%AE%BE%E5%A4%87"><span class="toc-number">0.2.4.</span> <span class="toc-text">触摸设备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.5.</span> <span class="toc-text">HTML5事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.6.</span> <span class="toc-text">设备事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%B8%8E%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.7.</span> <span class="toc-text">触摸与手势事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.7.1.</span> <span class="toc-text">触摸事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Touch%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">0.2.7.2.</span> <span class="toc-text">Touch对象属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%8B%E5%8A%BF%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.7.3.</span> <span class="toc-text">手势事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">0.2.8.</span> <span class="toc-text">事件委托</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E8%A1%A8%E5%8D%95%E8%84%9A%E6%9C%AC"><span class="toc-number"></span> <span class="toc-text">十四.表单脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">0.1.</span> <span class="toc-text">表单基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95"><span class="toc-number">0.1.1.</span> <span class="toc-text">提交表单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E8%A1%A8%E5%8D%95"><span class="toc-number">0.1.2.</span> <span class="toc-text">重置表单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%AD%97%E6%AE%B5"><span class="toc-number">0.1.3.</span> <span class="toc-text">表单字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%A1%86%E8%84%9A%E6%9C%AC"><span class="toc-number">0.2.</span> <span class="toc-text">文本框脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%96%87%E6%9C%AC"><span class="toc-number">0.2.1.</span> <span class="toc-text">选择文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E8%BE%93%E5%85%A5"><span class="toc-number">0.2.2.</span> <span class="toc-text">过滤输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTML5%E7%BA%A6%E6%9D%9F%E9%AA%8C%E8%AF%81API"><span class="toc-number">0.2.3.</span> <span class="toc-text">HTML5约束验证API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">0.2.3.1.</span> <span class="toc-text">输入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-number">0.2.3.1.1.</span> <span class="toc-text">检测有效性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E9%AA%8C%E8%AF%81"><span class="toc-number">0.2.3.1.2.</span> <span class="toc-text">禁用验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%A1%86%E8%84%9A%E6%9C%AC"><span class="toc-number">0.2.4.</span> <span class="toc-text">选择框脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">0.2.5.</span> <span class="toc-text">富文本编辑器</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-HTML5-%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">十六. HTML5 脚本编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">0.1.</span> <span class="toc-text">跨文档消息传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E6%8B%96%E6%94%BE"><span class="toc-number">0.2.</span> <span class="toc-text">原生拖放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%96%E6%94%BE%E4%BA%8B%E4%BB%B6"><span class="toc-number">0.2.1.</span> <span class="toc-text">拖放事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dataTransfer%E5%AF%B9%E8%B1%A1"><span class="toc-number">0.2.2.</span> <span class="toc-text">dataTransfer对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#drapEffect-%E4%B8%8E-effectAllowed"><span class="toc-number">0.2.3.</span> <span class="toc-text">drapEffect 与 effectAllowed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%8B%96%E5%8A%A8"><span class="toc-number">0.2.4.</span> <span class="toc-text">可拖动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98"><span class="toc-number">0.2.5.</span> <span class="toc-text">其他成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E5%85%83%E7%B4%A0"><span class="toc-number">0.3.</span> <span class="toc-text">媒体元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#audio%E5%85%83%E7%B4%A0%E7%9A%84%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">0.3.1.</span> <span class="toc-text">audio元素的常用属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">十七. 错误处理与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">try-catch 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#finally%E5%AD%90%E5%8F%A5"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">finally子句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">错误类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">抛出错误</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">自定义错误类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Error%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">Error事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">常见的错误类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E8%87%B4%E5%91%BD%E9%94%99%E8%AF%AF%E5%92%8C%E9%9D%9E%E8%87%B4%E5%91%BD%E9%94%99%E8%AF%AF"><span class="toc-number">1.1.5.</span> <span class="toc-text">区分致命错误和非致命错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.1.6.</span> <span class="toc-text">把错误记录到服务器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.</span> <span class="toc-text">调试技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-JavaScript%E4%B8%8EXML"><span class="toc-number"></span> <span class="toc-text">十八.  JavaScript与XML</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D-E4X"><span class="toc-number"></span> <span class="toc-text">十九. E4X</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81-canvas"><span class="toc-number"></span> <span class="toc-text">二十. canvas</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/03/07/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/" title="代码提交管理规范"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码提交管理规范"/></a><div class="content"><a class="title" href="/2024/03/07/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83/" title="代码提交管理规范">代码提交管理规范</a><time datetime="2024-03-07T00:59:59.000Z" title="发表于 2024-03-07 08:59:59">2024-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/06/lerna-monorepo-%E5%AE%9E%E8%B7%B5/" title="lerna monorepo 实践"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="lerna monorepo 实践"/></a><div class="content"><a class="title" href="/2024/03/06/lerna-monorepo-%E5%AE%9E%E8%B7%B5/" title="lerna monorepo 实践">lerna monorepo 实践</a><time datetime="2024-03-06T08:50:04.000Z" title="发表于 2024-03-06 16:50:04">2024-03-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/19/EditorConfig/" title="EditorConfig"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="EditorConfig"/></a><div class="content"><a class="title" href="/2024/02/19/EditorConfig/" title="EditorConfig">EditorConfig</a><time datetime="2024-02-19T08:55:27.000Z" title="发表于 2024-02-19 16:55:27">2024-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/07/%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="工程化"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="工程化"/></a><div class="content"><a class="title" href="/2024/02/07/%E5%B7%A5%E7%A8%8B%E5%8C%96/" title="工程化">工程化</a><time datetime="2024-02-07T05:32:31.378Z" title="发表于 2024-02-07 13:32:31">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/08/hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/" title="hexo 搭建自己博客心得"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hexo 搭建自己博客心得"/></a><div class="content"><a class="title" href="/2023/12/08/hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2%E5%BF%83%E5%BE%97/" title="hexo 搭建自己博客心得">hexo 搭建自己博客心得</a><time datetime="2023-12-08T02:35:20.000Z" title="发表于 2023-12-08 10:35:20">2023-12-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ms.y</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>